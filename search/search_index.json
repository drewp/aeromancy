{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Aeromancy","text":"<p>Aeromancy is an opinionated philosophy and open-sourced framework that closely tracks experimental runtime environments for more reproducible machine learning. In existing experiment trackers, it\u2019s easy to miss important details about how an experiment was run, e.g., which version of a dataset was used as input or the exact versions of library dependencies. Missing these details can make replicability more difficult. Aeromancy aims to make this process smoother by providing both new infrastructure (a more comprehensive versioning scheme including both system runtimes and external datasets) and a corresponding set of best practices to ensure experiments are maximally trackable.</p> <p>In its current form, Aeromancy requires a fairly specific software stack:</p> <ul> <li>Experiment tracker: Weights and Biases</li> <li>Object storage (artifacts): S3-compatible, e.g.,   Ceph</li> <li>Virtualization: Docker</li> </ul> <p>Note: As is likely obvious, Aeromancy documentation is in a very early state. As this is a pre-release support may be limited. For now, we include a couple pointers for how to setup your environment for Aeromancy.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Coming soon: A proper Getting Started section.</p> <p>To quickly set up an Aeromancy project, we've created a Copier template. See instructions at the quant-aq/aeromancy-project-template.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.10.5 or higher</li> <li><code>pdm</code>: Install via <code>pip install --user pdm</code> then   install Aeromancy packages with <code>pdm install</code>.</li> <li>Environment variables:</li> <li>S3 backend location and credentials:<ul> <li><code>AEROMANCY_AWS_ACCESS_KEY_ID</code></li> <li><code>AEROMANCY_AWS_SECRET_ACCESS_KEY</code></li> <li><code>AEROMANCY_AWS_S3_ENDPOINT_URL</code></li> <li><code>AEROMANCY_AWS_REGION</code></li> </ul> </li> <li><code>WANDB_API_KEY</code> (from Weights and Biases)</li> <li>SSH Authentication: You'll want <code>ssh-agent</code> setup if you need to access   private GitHub repositories. Check out these   instructions.</li> </ul>"},{"location":"#mac-os","title":"Mac OS","text":"<ul> <li>Use Homebrew to install the following:</li> <li><code>brew install apache-arrow@13.0.0_5 bat@0.23.0 graphviz@8.1.0     openblas@0.3.24 pre-commit@3.3.3</code></li> <li>Install Docker Desktop from docker.com (not Brew   since it has a trickier upgrade story)</li> </ul>"},{"location":"#common-commands","title":"Common commands","text":"<ul> <li><code>pdm lint</code>: Run pre-commit linters</li> <li><code>pdm test</code>: Run test suite</li> <li><code>pdm doc</code>: Start doc server (see also the public   version for the latest checked in   version)</li> </ul>"},{"location":"scaffolding/","title":"Aeromancy scaffolding","text":"<p>In order to enable tracking, Aeromancy is rather opinionated about how projects are set up. A \"project\" in this case means a pipeline of tasks, potentially configurable through CLI flags. This document provides an overview of the components involved and how to set up a new Aeromancy project.</p> <p>This diagram roughly shows the flow:</p> <pre><code>graph LR\n    pdmgo[shell&gt; pdm go] --&gt;|runs| runner[aeromancy.runner]\n    subgraph pdm [pdm virtualenv]\n        runner --&gt;|runs| aeromain\n        runner --&gt;|builds| Dockerfile\n        Dockerfile --&gt;|specifies container| docker\n        subgraph docker [docker image]\n            subgraph projectspecific [project-specific code]\n                aeromain --&gt; etc[...]\n            end\n        end\n    end\n    pdmgo --&gt;|script defined by| pyproject[pyproject.toml]\n    pyproject --&gt;|customizes via build args| Dockerfile\n\n    %% Project specific (blue)\n    style projectspecific stroke:blue\n    style pdm stroke:blue\n    style pdmgo stroke:blue\n    style docker stroke:blue\n    style aeromain stroke:blue\n    style etc stroke:blue\n    style pyproject stroke:blue\n    %% Aeromancy provided (red)\n    style runner stroke:red\n    style Dockerfile stroke:red</code></pre> <p>(red indicates something provided by Aeromancy, blue indicates something specific to the user's project)</p>"},{"location":"scaffolding/#entry-points","title":"Entry points","text":"<p>In order to run pipelines with full tracking, Aeromancy runs project-specific code inside a Docker container. This means that we end up with two main-like files:</p> <ol> <li>One provided by Aeromancy that lives outside the container to set up the container (<code>aeromancy.runner</code>) and</li> <li>A project-specific one that runs inside the container (the project's \"AeroMain\").</li> </ol>"},{"location":"scaffolding/#the-aeromancyrunner-module","title":"The <code>aeromancy.runner</code> module","text":"<p>Aeromancy pipelines are invoked by a PDM script called <code>pdm go</code> which launches <code>aeromancy.runner</code> inside PDM's virtual environment.</p> <p><code>aeromancy.runner</code> sets up the runtime environment and, in the common case, and launches AeroMain inside a Docker container. This may include several customizations, including additional <code>docker run</code> flags (e.g., to set additional volumes) and extra Debian packages to include in the Docker image.</p> <p>(NOTE: In development mode, we bypass Docker for speed and run AeroMain directly in a subprocess.)</p>"},{"location":"scaffolding/#inside-aeromain","title":"Inside AeroMain","text":"<p>AeroMain parses project-specific command line flags to determine common configuration options. It then instantiates a project-specific <code>ActionBuilder</code> class. This class is responsible for generating sequences of project-specific <code>Action</code> objects and their dependency structures. Finally, it hands off the <code>ActionBuilder</code> to an <code>ActionRunner</code> to actually executes the generated <code>Action</code>s.</p> <p>See Tasks, Trackers, and Actions for more information on these objects.</p>"},{"location":"scaffolding/#creating-a-new-aeromancy-project","title":"Creating a new Aeromancy project","text":"<p>In order to set up a new project, you'll need a Git repository with these components:</p> <ul> <li>Actions (subclasses of <code>Action</code> with specific logic   for your tasks)</li> <li>An <code>ActionBuilder</code> to instantiate   the <code>Action</code> objects and describe their   dependencies</li> <li>An \"AeroMain\" script to parse any project-specific options and bring it all   together</li> </ul> <p>To quickly set up an Aeromancy project, we've created a Copier template. See instructions at the quant-aq/aeromancy-project-template. In the generated Python project setup (<code>pyproject.toml</code>), you may also want to adjust:</p> <ul> <li>Extra Python packages: Add them with <code>pdm add &lt;pkgname&gt;</code>. See PDM   docs for more information on   this.</li> <li><code>pdm</code> scripts: Some of   these are necessary for running Aeromancy (like <code>pdm go</code>), but you can add   more if there are common tasks for your project.</li> <li>Extra <code>docker run</code> arguments: E.g., mounting   volumes).   These can be baked <code>pdm go</code> script with <code>--extra-docker-run-args='...'</code>.</li> <li>Extra Debian packages: (outside of those included by Aeromancy), you may   want to bake them into the <code>pdm go</code> script with <code>--extra-debian-package='...'</code>   (specify the flag once per package name).</li> <li>Development environment (linters, etc.): Aeromancy encourages the use of   the <code>ruff</code> linter and <code>Black</code> formatter, but these are customizable.</li> </ul>"},{"location":"scaffolding/#filesystem-layout","title":"Filesystem layout","text":"<p>Ultimately, the structure of an Aeromancy project should look something like this:</p> <pre><code>&lt;projectroot&gt;/\n  pyproject.toml\n  pdm.lock\n  main.py  # AeroMain\n  src/\n    &lt;projectname&gt;/\n      &lt;youractions&gt;.py\n      &lt;youractionbuilder&gt;.py\n</code></pre> <p>The structure of the classes containing your <code>Action</code>(s) and <code>ActionBuilder</code> is flexible -- they just need to be importable in AeroMain.</p>"},{"location":"tasks/","title":"Tasks, Trackers, and Actions: Your guide to Aeromancy's Terminological Soup","text":"<p>The terminology can get confusing here, as there are several similarly named but functionally different pieces. The following diagram summarizes the key relationships:</p> <pre><code>graph LR\n  ActionBuilder --&gt;|Convertible to| ActionRunner\n  ActionBuilder --&gt;|Builds| Action\n  Action --&gt;|Instantiates| Tracker\n  WandbTracker --&gt;|Subclasses| Tracker\n  FakeTracker --&gt;|Subclasses| Tracker\n  Action --&gt;|Convertible to| Task[pydoit.Task]\n  ActionRunner --&gt;|Executes| Task</code></pre>"},{"location":"tasks/#tracker","title":"<code>Tracker</code>","text":"<p>Creates an environment for to track code for reproducible ML/data science/data pipelines/etc. For example, <code>WandbTracker</code> (a subclass) integrates with Weights and Biases (W&amp;B) for ML experiment tracking and S3 for external artifact storage. This class doesn't know anything task-specific, dependencies between tasks, or how to actually execute the code.</p>"},{"location":"tasks/#action","title":"<code>Action</code>","text":"<p>A single task-specific node in an execution graph. Each node knows its inputs (other <code>Action</code>s it depends on and the results of their computation) and outputs as well as the actual code to run the action. We wrap the execution of an <code>Action</code> in an Aeromancy <code>Tracker</code> when run (potentially a <code>FakeTracker</code> for development work). <code>Action</code>s know a little about W&amp;B artifact names since they need to declare and look these up. <code>Action</code>s are agnostic about how/where they actually gets executed -- that's up to a task runner which we can swap out as needed (see <code>ActionRunner</code>).</p>"},{"location":"tasks/#actionbuilder","title":"<code>ActionBuilder</code>","text":"<p>A factory class that constructs <code>Action</code>s with specified dependencies for a given configuration.</p>"},{"location":"tasks/#actionrunner","title":"<code>ActionRunner</code>","text":"<p>Uses <code>pydoit</code> to execute <code>Action</code>s in an <code>ActionBuilder</code> (according to dependencies it laid out). This includes logic to convert <code>Action</code>s to pydoit <code>Task</code>s.</p>"},{"location":"tasks/#task-pydoit","title":"<code>Task</code> (pydoit)","text":"<p>A single executable task with dependencies and metadata in <code>pydoit</code>'s framework. All logic for working with these lives in the <code>aeromancy.action_runner</code> module.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>aeromancy<ul> <li>action</li> <li>action_builder</li> <li>action_runner</li> <li>aeroview</li> <li>artifacts</li> <li>click_options</li> <li>export_utils</li> <li>fake_tracker</li> <li>rerun</li> <li>runner</li> <li>runtime_environment</li> <li>s3</li> <li>struct</li> <li>tracker</li> <li>wandb_tracker</li> </ul> </li> <li>bogus_aeromain</li> </ul>"},{"location":"reference/bogus_aeromain/","title":"bogus_aeromain","text":"<p>A bogus Aeromain for testing Aeromancy outside of Aeromancy projects.</p> <p>This is enough to test both <code>--dev</code> mode. You can launch it with something like:</p> <pre><code>shell&gt; pdm debug_runner --aeromain src/bogus_aeromain.py --dev\n</code></pre> <p>Beyond that, flags are as they would be for a normal <code>pdm go</code> in an Aeromancy project repo.</p> <p>TODO: Full Docker integration doesn't currently work.</p>"},{"location":"reference/bogus_aeromain/#bogus_aeromain.BogusActionBuilder","title":"<code>BogusActionBuilder</code>","text":"<p>             Bases: <code>ActionBuilder</code></p> <p>Bogus Aeromancy <code>ActionBuilder</code> for testing.</p> <p>Creates a single <code>BogusAction</code>.</p> Source code in <code>src/bogus_aeromain.py</code> <pre><code>class BogusActionBuilder(ActionBuilder):\n    \"\"\"Bogus Aeromancy `ActionBuilder` for testing.\n\n    Creates a single `BogusAction`.\n    \"\"\"\n\n    @override\n    def build_actions(self) -&gt; list[Action]:\n        actions = []\n        parent_action = self.add_action(actions, BogusParentAction(parents=[]))\n        self.add_action(actions, BogusChildAction(parents=[parent_action]))\n        return actions\n</code></pre>"},{"location":"reference/bogus_aeromain/#bogus_aeromain.BogusChildAction","title":"<code>BogusChildAction</code>","text":"<p>             Bases: <code>Action</code></p> <p>Bogus Aeromancy <code>Action</code> for testing.</p> <p>Prints a message to let you know it ran and reads an input artifact from the parent.</p> Source code in <code>src/bogus_aeromain.py</code> <pre><code>class BogusChildAction(Action):\n    \"\"\"Bogus Aeromancy `Action` for testing.\n\n    Prints a message to let you know it ran and reads an input artifact from the\n    parent.\n    \"\"\"\n\n    job_type = \"child\"\n    job_group = \"bogus\"\n\n    @override\n    def outputs(self) -&gt; list[str]:\n        return [\"bogus-child\"]\n\n    @override\n    def run(self, tracker: Tracker) -&gt; None:\n        [input_artifact], _ = self.get_io()\n        [input_path] = tracker.declare_input(input_artifact)\n\n        print(\"Hello world from BogusChildAction.\")\n        print(\n            \"Parent action created artifact with this text: \"\n            f\"{input_path.read_text()!r}\",\n        )\n</code></pre>"},{"location":"reference/bogus_aeromain/#bogus_aeromain.BogusParentAction","title":"<code>BogusParentAction</code>","text":"<p>             Bases: <code>Action</code></p> <p>Bogus Aeromancy <code>Action</code> for testing.</p> <p>Prints a message to let you know it ran and creates an output artifact.</p> Source code in <code>src/bogus_aeromain.py</code> <pre><code>class BogusParentAction(Action):\n    \"\"\"Bogus Aeromancy `Action` for testing.\n\n    Prints a message to let you know it ran and creates an output artifact.\n    \"\"\"\n\n    job_type = \"parent\"\n    job_group = \"bogus\"\n\n    @override\n    def outputs(self) -&gt; list[str]:\n        return [\"bogus-parent\"]\n\n    @override\n    def run(self, tracker: Tracker) -&gt; None:\n        output_path = Path(\"/tmp/bogus-output1.txt\")  # noqa: S108\n        output_path.write_text(\"BogusParentAction output!\\n\")\n\n        [output_name] = self.outputs()\n        tracker.declare_output(\n            name=output_name,\n            local_filenames=[output_path],\n            s3_destination=S3Object(\"bogus-bucket\", \"key1/\"),\n            artifact_type=\"bogus-artifact\",\n            metadata={\"meaning-of-life\": 42},\n            strip_prefix=Path(\"/tmp\"),  # noqa: S108\n        )\n        print(\"Hello world from BogusParentAction.\")\n</code></pre>"},{"location":"reference/bogus_aeromain/#bogus_aeromain.aeromain","title":"<code>aeromain(**aeromancy_options)</code>","text":"<p>CLI application with a minimal Aeromain for Aeromancy development.</p> Source code in <code>src/bogus_aeromain.py</code> <pre><code>@click.command()\n@aeromancy_click_options\ndef aeromain(\n    **aeromancy_options,\n):\n    \"\"\"CLI application with a minimal Aeromain for Aeromancy development.\"\"\"\n    console.rule(\"[bold green][Bogus Aeromain][/bold green] Started!\")\n    action_builder = BogusActionBuilder(project_name=\"aeromancy-debug\")\n    action_runner = action_builder.to_runner()\n    action_runner.run_actions(**aeromancy_options)\n    console.rule(\"[bold green][Bogus Aeromain][/bold green] Done!\")\n</code></pre>"},{"location":"reference/aeromancy/","title":"aeromancy","text":"<p>Aeromancy: An experiment tracking/data pipeline management library.</p>"},{"location":"reference/aeromancy/#aeromancy.Action","title":"<code>Action</code>","text":"<p>A specific piece of work to track.</p> <p>This includes the code to run, artifacts it depends on, and artifacts it produces. For organizational purposes, they can fill in class variables:</p> <ul> <li><code>job_type</code></li> <li><code>job_group</code></li> </ul> <p>(<code>job_group</code> is more general than <code>job_type</code>. Semantics are up to the project design and <code>Tracker</code> backend.)</p> Source code in <code>aeromancy/action.py</code> <pre><code>class Action:\n    \"\"\"A specific piece of work to track.\n\n    This includes the code to run, artifacts it depends on, and artifacts it\n    produces. For organizational purposes, they can fill in class variables:\n\n    - `job_type`\n    - `job_group`\n\n    (`job_group` is more general than `job_type`. Semantics are up to the\n    project design and `Tracker` backend.)\n    \"\"\"\n\n    # Properties for subclasses to fill in.\n    job_type: str | None = None\n    job_group: str | None = None\n\n    def __init__(self, parents: list[\"Action\"], **config):\n        \"\"\"Create an `Action`.\n\n        Parameters\n        ----------\n        parents\n            `Action`s that this `Action` depends on. These must be run first.\n        config\n            Any `Action`-specific configuration. If the `Action` were a function\n            call, these would be its parameters (e.g., hyperparameters for many\n            ML algorithms).\n        \"\"\"\n        self.config = config\n        self.parents = parents\n        self._tracker_class = WandbTracker\n        self._project_name = None\n\n    def outputs(self) -&gt; list[str]:\n        \"\"\"Describe what this `Action` will produce after being run.\n\n        Must be overridden.\n\n        Returns\n        -------\n            List of artifact names that this `Action` will produce.\n        \"\"\"\n        raise NotImplementedError\n\n    def run(self, tracker: Tracker) -&gt; None:\n        \"\"\"Execute this action.\n\n        This logic is Action-specific and must be overridden by subclasses.\n\n        Parameters\n        ----------\n        tracker\n            An Aeromancy `Tracker` for this task.\n        \"\"\"\n        raise NotImplementedError\n\n    # TODO: should return outputs()? Then we can store them between runs.\n    def _run(self) -&gt; None:\n        \"\"\"Actual run method that task runners call.\n\n        Should not be called directly.\n        \"\"\"\n        if self._project_name is None:\n            raise ValueError(\n                f\"Must set project_name on your Action class: {self.__class__}\",\n            )\n\n        with self._tracker_class(\n            job_type=self.job_type,\n            job_group=self.job_group,\n            config=self.config,\n            project_name=self._project_name,\n        ) as tracker:\n            self.run(tracker)\n\n    def _set_tracker(self, tracker_class: type[Tracker]) -&gt; None:\n        \"\"\"Set a different class to use for tracking.\n\n        This should only be called under special circumstances (e.g., testing\n        environments, offline mode).\n        \"\"\"\n        self._tracker_class = tracker_class\n\n    def get_io(self, resolve_outputs=False) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Get inputs and outputs for this `Action`.\n\n        Parameters\n        ----------\n        resolve_outputs, optional\n            If set, output artifacts will be versioned\n\n        Returns\n        -------\n            Tuple with names of (input artifacts, output artifacts)\n        \"\"\"\n        parent_outputs = []\n        for parent in self.parents:\n            parent_outputs.extend(parent.outputs())\n        full_inputs = [\n            WandbArtifactName.resolve_artifact_name(\n                artifact_name,\n                default_project_name=self._project_name,\n            )\n            for artifact_name in parent_outputs\n        ]\n        full_outputs = self.outputs()\n        if resolve_outputs:\n            full_outputs = [\n                WandbArtifactName.resolve_artifact_name(\n                    artifact_name,\n                    default_project_name=self._project_name,\n                )\n                for artifact_name in full_outputs\n            ]\n        return (full_inputs, full_outputs)\n\n    def _set_runtime_properties(self, project_name: str, skip: bool):\n        \"\"\"Set properties that we won't know until we're ready to run.\"\"\"\n        self._skip = skip\n        self._project_name = project_name\n\n    skip = property(lambda self: self._skip, doc=\"Whether this action should be run\")\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Action.__init__","title":"<code>__init__(parents, **config)</code>","text":"<p>Create an <code>Action</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parents</code> <code>list[Action]</code> <p><code>Action</code>s that this <code>Action</code> depends on. These must be run first.</p> required <code>config</code> <p>Any <code>Action</code>-specific configuration. If the <code>Action</code> were a function call, these would be its parameters (e.g., hyperparameters for many ML algorithms).</p> <code>{}</code> Source code in <code>aeromancy/action.py</code> <pre><code>def __init__(self, parents: list[\"Action\"], **config):\n    \"\"\"Create an `Action`.\n\n    Parameters\n    ----------\n    parents\n        `Action`s that this `Action` depends on. These must be run first.\n    config\n        Any `Action`-specific configuration. If the `Action` were a function\n        call, these would be its parameters (e.g., hyperparameters for many\n        ML algorithms).\n    \"\"\"\n    self.config = config\n    self.parents = parents\n    self._tracker_class = WandbTracker\n    self._project_name = None\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Action.get_io","title":"<code>get_io(resolve_outputs=False)</code>","text":"<p>Get inputs and outputs for this <code>Action</code>.</p> <p>Parameters:</p> Name Type Description Default <code>resolve_outputs</code> <p>If set, output artifacts will be versioned</p> <code>False</code> <code>optional</code> <p>If set, output artifacts will be versioned</p> <code>False</code> <p>Returns:</p> Type Description <code>    Tuple with names of (input artifacts, output artifacts)</code> Source code in <code>aeromancy/action.py</code> <pre><code>def get_io(self, resolve_outputs=False) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Get inputs and outputs for this `Action`.\n\n    Parameters\n    ----------\n    resolve_outputs, optional\n        If set, output artifacts will be versioned\n\n    Returns\n    -------\n        Tuple with names of (input artifacts, output artifacts)\n    \"\"\"\n    parent_outputs = []\n    for parent in self.parents:\n        parent_outputs.extend(parent.outputs())\n    full_inputs = [\n        WandbArtifactName.resolve_artifact_name(\n            artifact_name,\n            default_project_name=self._project_name,\n        )\n        for artifact_name in parent_outputs\n    ]\n    full_outputs = self.outputs()\n    if resolve_outputs:\n        full_outputs = [\n            WandbArtifactName.resolve_artifact_name(\n                artifact_name,\n                default_project_name=self._project_name,\n            )\n            for artifact_name in full_outputs\n        ]\n    return (full_inputs, full_outputs)\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Action.outputs","title":"<code>outputs()</code>","text":"<p>Describe what this <code>Action</code> will produce after being run.</p> <p>Must be overridden.</p> <p>Returns:</p> Type Description <code>    List of artifact names that this `Action` will produce.</code> Source code in <code>aeromancy/action.py</code> <pre><code>def outputs(self) -&gt; list[str]:\n    \"\"\"Describe what this `Action` will produce after being run.\n\n    Must be overridden.\n\n    Returns\n    -------\n        List of artifact names that this `Action` will produce.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Action.run","title":"<code>run(tracker)</code>","text":"<p>Execute this action.</p> <p>This logic is Action-specific and must be overridden by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>tracker</code> <code>Tracker</code> <p>An Aeromancy <code>Tracker</code> for this task.</p> required Source code in <code>aeromancy/action.py</code> <pre><code>def run(self, tracker: Tracker) -&gt; None:\n    \"\"\"Execute this action.\n\n    This logic is Action-specific and must be overridden by subclasses.\n\n    Parameters\n    ----------\n    tracker\n        An Aeromancy `Tracker` for this task.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.ActionBuilder","title":"<code>ActionBuilder</code>","text":"<p>Sets up and runs (via pydoit) a computation graph over <code>Action</code>s.</p> <p>Subclasses must implement <code>build_actions</code>.</p> Source code in <code>aeromancy/action_builder.py</code> <pre><code>class ActionBuilder:\n    \"\"\"Sets up and runs (via pydoit) a computation graph over `Action`s.\n\n    Subclasses must implement `build_actions`.\n    \"\"\"\n\n    def __init__(self, project_name):\n        \"\"\"Create an `ActionBuilder`.\n\n        Parameters\n        ----------\n        project_name\n            The project that the `Action`s created by this should live in.\n        \"\"\"\n        self._project_name = project_name\n\n    def build_actions(self) -&gt; list[Action]:\n        \"\"\"Produce a list of `Action`s to run.\n\n        This must be implemented by subclasses.\n\n        For each action, you should use the `add_action` helper to add it to a\n        local list of `Action`s. This will help you set internal states on\n        `Action`s (e.g., if an action should be skipped under the current\n        configuration). For example:\n\n        ```\n            def build_actions(self):\n                actions = []\n                a1 = self.add_action(actions, Action1(), skip=True)\n                a2 = self.add_action(actions, Action2(parents=[a1]), skip=False)\n                a3 = self.add_action(actions, Action3(parents=[a1]), skip=False)\n                a4 = self.add_action(actions, Action4(parents=[a2, a3]), skip=False)\n                return actions\n        ```\n\n        Returns\n        -------\n            List of `Actions` to run.\n        \"\"\"\n        raise NotImplementedError\n\n    def add_action(\n        self,\n        actions: list[Action],\n        action: ActionType,\n        skip: bool = False,\n    ) -&gt; ActionType:\n        \"\"\"Add an `Action` while setting run state for the `Action`.\n\n        See `build_actions` for more details and example usage.\n\n        Parameters\n        ----------\n        actions\n            A growing list of `Action`s, built up in a `build_actions` method\n        action\n            `Action` to add to `actions`\n        skip, optional\n            Whether the `action` should not be run, by default False\n\n        Returns\n        -------\n            The `Action` passed as `action`, with additional run state added\n        \"\"\"\n        action._set_runtime_properties(self._project_name, skip=skip)\n        actions.append(action)\n        return action\n\n    def to_runner(self) -&gt; ActionRunner:\n        \"\"\"Convert to an `ActionRunner` for running these actions.\n\n        Returns\n        -------\n            An `ActionRunner` which can run the `Actions` specified in\n            `build_actions` using pydoit.\n        \"\"\"\n        return ActionRunner(self.build_actions())\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.ActionBuilder.__init__","title":"<code>__init__(project_name)</code>","text":"<p>Create an <code>ActionBuilder</code>.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <p>The project that the <code>Action</code>s created by this should live in.</p> required Source code in <code>aeromancy/action_builder.py</code> <pre><code>def __init__(self, project_name):\n    \"\"\"Create an `ActionBuilder`.\n\n    Parameters\n    ----------\n    project_name\n        The project that the `Action`s created by this should live in.\n    \"\"\"\n    self._project_name = project_name\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.ActionBuilder.add_action","title":"<code>add_action(actions, action, skip=False)</code>","text":"<p>Add an <code>Action</code> while setting run state for the <code>Action</code>.</p> <p>See <code>build_actions</code> for more details and example usage.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list[Action]</code> <p>A growing list of <code>Action</code>s, built up in a <code>build_actions</code> method</p> required <code>action</code> <code>ActionType</code> <p><code>Action</code> to add to <code>actions</code></p> required <code>skip</code> <code>bool</code> <p>Whether the <code>action</code> should not be run, by default False</p> <code>False</code> <code>optional</code> <code>bool</code> <p>Whether the <code>action</code> should not be run, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>    The `Action` passed as `action`, with additional run state added</code> Source code in <code>aeromancy/action_builder.py</code> <pre><code>def add_action(\n    self,\n    actions: list[Action],\n    action: ActionType,\n    skip: bool = False,\n) -&gt; ActionType:\n    \"\"\"Add an `Action` while setting run state for the `Action`.\n\n    See `build_actions` for more details and example usage.\n\n    Parameters\n    ----------\n    actions\n        A growing list of `Action`s, built up in a `build_actions` method\n    action\n        `Action` to add to `actions`\n    skip, optional\n        Whether the `action` should not be run, by default False\n\n    Returns\n    -------\n        The `Action` passed as `action`, with additional run state added\n    \"\"\"\n    action._set_runtime_properties(self._project_name, skip=skip)\n    actions.append(action)\n    return action\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.ActionBuilder.build_actions","title":"<code>build_actions()</code>","text":"<p>Produce a list of <code>Action</code>s to run.</p> <p>This must be implemented by subclasses.</p> <p>For each action, you should use the <code>add_action</code> helper to add it to a local list of <code>Action</code>s. This will help you set internal states on <code>Action</code>s (e.g., if an action should be skipped under the current configuration). For example:</p> <pre><code>    def build_actions(self):\n        actions = []\n        a1 = self.add_action(actions, Action1(), skip=True)\n        a2 = self.add_action(actions, Action2(parents=[a1]), skip=False)\n        a3 = self.add_action(actions, Action3(parents=[a1]), skip=False)\n        a4 = self.add_action(actions, Action4(parents=[a2, a3]), skip=False)\n        return actions\n</code></pre> <p>Returns:</p> Type Description <code>    List of `Actions` to run.</code> Source code in <code>aeromancy/action_builder.py</code> <pre><code>def build_actions(self) -&gt; list[Action]:\n    \"\"\"Produce a list of `Action`s to run.\n\n    This must be implemented by subclasses.\n\n    For each action, you should use the `add_action` helper to add it to a\n    local list of `Action`s. This will help you set internal states on\n    `Action`s (e.g., if an action should be skipped under the current\n    configuration). For example:\n\n    ```\n        def build_actions(self):\n            actions = []\n            a1 = self.add_action(actions, Action1(), skip=True)\n            a2 = self.add_action(actions, Action2(parents=[a1]), skip=False)\n            a3 = self.add_action(actions, Action3(parents=[a1]), skip=False)\n            a4 = self.add_action(actions, Action4(parents=[a2, a3]), skip=False)\n            return actions\n    ```\n\n    Returns\n    -------\n        List of `Actions` to run.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.ActionBuilder.to_runner","title":"<code>to_runner()</code>","text":"<p>Convert to an <code>ActionRunner</code> for running these actions.</p> <p>Returns:</p> Type Description <code>    An `ActionRunner` which can run the `Actions` specified in</code> <p><code>build_actions</code> using pydoit.</p> Source code in <code>aeromancy/action_builder.py</code> <pre><code>def to_runner(self) -&gt; ActionRunner:\n    \"\"\"Convert to an `ActionRunner` for running these actions.\n\n    Returns\n    -------\n        An `ActionRunner` which can run the `Actions` specified in\n        `build_actions` using pydoit.\n    \"\"\"\n    return ActionRunner(self.build_actions())\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.AeromancyArtifact","title":"<code>AeromancyArtifact</code>","text":"<p>             Bases: <code>Struct</code></p> <p>External artifact produced and/or consumed by Aeromancy <code>Action</code>s.</p> <p>This class includes information to simultaneously track external files using Weights and Biases and a S3-compatible storage provider.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The artifact name (should comply with Weights and Biases naming scheme, see <code>validate_wandb_artifact_string</code>).</p> <code>artifact_type</code> <code>str</code> <p>Free text string to be associated with the artifact (should comply with Weights and Biases naming scheme, see <code>validate_wandb_artifact_string</code>). Semantics are up to project-specific conventions, but recommendation is a simple human-readable description of the extension.</p> <code>s3</code> <code>list[VersionedS3Object]</code> <p>S3 references for the contents of this artifact.</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>class AeromancyArtifact(msgspec.Struct):\n    \"\"\"External artifact produced and/or consumed by Aeromancy `Action`s.\n\n    This class includes information to simultaneously track external files using\n    Weights and Biases and a S3-compatible storage provider.\n\n    Attributes\n    ----------\n    name\n        The artifact name (should comply with Weights and Biases naming scheme,\n        see `validate_wandb_artifact_string`).\n    artifact_type\n        Free text string to be associated with the artifact (should comply with\n        Weights and Biases naming scheme, see `validate_wandb_artifact_string`).\n        Semantics are up to project-specific conventions, but recommendation is\n        a simple human-readable description of the extension.\n    s3\n        S3 references for the contents of this artifact.\n    \"\"\"\n\n    name: str\n    artifact_type: str\n    s3: list[VersionedS3Object]\n\n    def __post_init__(self):\n        \"\"\"Validate our inputs.\"\"\"\n        # We don't know for sure that Weights and Biases holds artifact type\n        # strings subject to the same constraints as artifact name, but we'll\n        # enforce it here out of paranoia.\n        _validate_wandb_artifact_string(self.name, \"artifact\")\n        _validate_wandb_artifact_string(self.artifact_type, \"artifact type\")\n\n    @classmethod\n    def from_wandb_api_artifact(cls, wandb_api_artifact: WandbApiArtifact):\n        \"\"\"Create an `AeromancyArtifact` from a Weights and Biases API artifact.\n\n        Parameters\n        ----------\n        wandb_api_artifact\n            Artifact to convert. Note that this is a Weights and Biases *API*\n            Artifact, which is distinct from the typical Weights and Biases\n            Artifact.\n\n        Returns\n        -------\n            An `AeromancyArtifact` corresponding to `wandb_api_artifact`\n        \"\"\"\n        s3_objects = []\n        for _, manifest_value in sorted(wandb_api_artifact.manifest.entries.items()):\n            if manifest_value.ref is None:\n                raise ValueError(\"No URI associated with manifest entry\")\n            aeromancy_uri = hyperlink.parse(manifest_value.ref)\n            s3 = VersionedS3Object.from_aeromancy_uri(aeromancy_uri)\n            s3_objects.append(s3)\n\n        artifact_type = wandb_api_artifact.type\n        artifact_name = WandbArtifactName.parse(wandb_api_artifact.name)\n\n        return AeromancyArtifact(\n            s3=s3_objects,\n            artifact_type=artifact_type,\n            name=artifact_name.artifact_name,\n        )\n\n    def as_wandb_artifact(\n        self,\n        metadata: dict | None = None,\n    ) -&gt; wandb.Artifact:\n        \"\"\"Convert this into a Weights and Biases `Artifact`.\n\n        Parameters\n        ----------\n        metadata, optional\n            Optional fields to associate with the `Artifact`. These will be\n            stored and accessible on Weights and Biases.\n\n        Returns\n        -------\n            This object represented as a Weights and Biases `Artifact`.\n        \"\"\"\n        primary_s3 = self.s3[0]\n        # Metadata here is intended as a debugging aid.\n        # We make a copy since we're going to modify it and the caller doesn't expect it\n        # to change.\n        metadata = dict(metadata or {})\n        metadata.update(\n            primary_s3_key=primary_s3.key,\n            primary_s3_bucket=primary_s3.bucket,\n            primary_s3_version=primary_s3.version_id,\n            # For viewing this Artifact on an S3 viewer webpage.\n            viewer_url=self.to_s3_viewer_url(),\n            num_files=len(self.s3),\n        )\n\n        description = f\"{primary_s3.bucket}/{primary_s3.key}\"\n        if len(self.s3) &gt; 1:\n            description = f\"{description} (+{len(self.s3) - 1} others)\"\n        artifact = wandb.Artifact(\n            name=self.name,\n            description=description,\n            type=self.artifact_type,\n            metadata=metadata,\n        )\n        # We need an external reference so W&amp;B knows when it changes.\n        for s3 in self.s3:\n            artifact.add_reference(name=s3.key, uri=str(s3.to_aeromancy_uri()))\n        return artifact\n\n    # TODO: Generalize this for non-DigitalOcean users.\n    def to_s3_viewer_url(self) -&gt; hyperlink.URL:\n        \"\"\"Return a URL to view the Artifact files on a web-based S3 viewer.\n\n        Returns\n        -------\n            URL for viewing the Artifact.\n        \"\"\"\n        primary_s3 = self.s3[0]\n\n        query = {}\n        key = Path(primary_s3.key)\n        if len(key.parts) &gt; 1:\n            # View the parent directory in DigitalOcean.\n            query = {\"path\": f\"{key.parent}/\"}\n\n        return hyperlink.URL(\n            scheme=\"https\",\n            host=\"cloud.digitalocean.com\",\n            path=(\n                \"spaces\",\n                primary_s3.bucket,\n            ),\n            query=query,\n        )\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.AeromancyArtifact.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate our inputs.</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate our inputs.\"\"\"\n    # We don't know for sure that Weights and Biases holds artifact type\n    # strings subject to the same constraints as artifact name, but we'll\n    # enforce it here out of paranoia.\n    _validate_wandb_artifact_string(self.name, \"artifact\")\n    _validate_wandb_artifact_string(self.artifact_type, \"artifact type\")\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.AeromancyArtifact.as_wandb_artifact","title":"<code>as_wandb_artifact(metadata=None)</code>","text":"<p>Convert this into a Weights and Biases <code>Artifact</code>.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict | None</code> <p>Optional fields to associate with the <code>Artifact</code>. These will be stored and accessible on Weights and Biases.</p> <code>None</code> <code>optional</code> <code>dict | None</code> <p>Optional fields to associate with the <code>Artifact</code>. These will be stored and accessible on Weights and Biases.</p> <code>None</code> <p>Returns:</p> Type Description <code>    This object represented as a Weights and Biases `Artifact`.</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def as_wandb_artifact(\n    self,\n    metadata: dict | None = None,\n) -&gt; wandb.Artifact:\n    \"\"\"Convert this into a Weights and Biases `Artifact`.\n\n    Parameters\n    ----------\n    metadata, optional\n        Optional fields to associate with the `Artifact`. These will be\n        stored and accessible on Weights and Biases.\n\n    Returns\n    -------\n        This object represented as a Weights and Biases `Artifact`.\n    \"\"\"\n    primary_s3 = self.s3[0]\n    # Metadata here is intended as a debugging aid.\n    # We make a copy since we're going to modify it and the caller doesn't expect it\n    # to change.\n    metadata = dict(metadata or {})\n    metadata.update(\n        primary_s3_key=primary_s3.key,\n        primary_s3_bucket=primary_s3.bucket,\n        primary_s3_version=primary_s3.version_id,\n        # For viewing this Artifact on an S3 viewer webpage.\n        viewer_url=self.to_s3_viewer_url(),\n        num_files=len(self.s3),\n    )\n\n    description = f\"{primary_s3.bucket}/{primary_s3.key}\"\n    if len(self.s3) &gt; 1:\n        description = f\"{description} (+{len(self.s3) - 1} others)\"\n    artifact = wandb.Artifact(\n        name=self.name,\n        description=description,\n        type=self.artifact_type,\n        metadata=metadata,\n    )\n    # We need an external reference so W&amp;B knows when it changes.\n    for s3 in self.s3:\n        artifact.add_reference(name=s3.key, uri=str(s3.to_aeromancy_uri()))\n    return artifact\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.AeromancyArtifact.from_wandb_api_artifact","title":"<code>from_wandb_api_artifact(wandb_api_artifact)</code>  <code>classmethod</code>","text":"<p>Create an <code>AeromancyArtifact</code> from a Weights and Biases API artifact.</p> <p>Parameters:</p> Name Type Description Default <code>wandb_api_artifact</code> <code>Artifact</code> <p>Artifact to convert. Note that this is a Weights and Biases API Artifact, which is distinct from the typical Weights and Biases Artifact.</p> required <p>Returns:</p> Type Description <code>    An `AeromancyArtifact` corresponding to `wandb_api_artifact`</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>@classmethod\ndef from_wandb_api_artifact(cls, wandb_api_artifact: WandbApiArtifact):\n    \"\"\"Create an `AeromancyArtifact` from a Weights and Biases API artifact.\n\n    Parameters\n    ----------\n    wandb_api_artifact\n        Artifact to convert. Note that this is a Weights and Biases *API*\n        Artifact, which is distinct from the typical Weights and Biases\n        Artifact.\n\n    Returns\n    -------\n        An `AeromancyArtifact` corresponding to `wandb_api_artifact`\n    \"\"\"\n    s3_objects = []\n    for _, manifest_value in sorted(wandb_api_artifact.manifest.entries.items()):\n        if manifest_value.ref is None:\n            raise ValueError(\"No URI associated with manifest entry\")\n        aeromancy_uri = hyperlink.parse(manifest_value.ref)\n        s3 = VersionedS3Object.from_aeromancy_uri(aeromancy_uri)\n        s3_objects.append(s3)\n\n    artifact_type = wandb_api_artifact.type\n    artifact_name = WandbArtifactName.parse(wandb_api_artifact.name)\n\n    return AeromancyArtifact(\n        s3=s3_objects,\n        artifact_type=artifact_type,\n        name=artifact_name.artifact_name,\n    )\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.AeromancyArtifact.to_s3_viewer_url","title":"<code>to_s3_viewer_url()</code>","text":"<p>Return a URL to view the Artifact files on a web-based S3 viewer.</p> <p>Returns:</p> Type Description <code>    URL for viewing the Artifact.</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def to_s3_viewer_url(self) -&gt; hyperlink.URL:\n    \"\"\"Return a URL to view the Artifact files on a web-based S3 viewer.\n\n    Returns\n    -------\n        URL for viewing the Artifact.\n    \"\"\"\n    primary_s3 = self.s3[0]\n\n    query = {}\n    key = Path(primary_s3.key)\n    if len(key.parts) &gt; 1:\n        # View the parent directory in DigitalOcean.\n        query = {\"path\": f\"{key.parent}/\"}\n\n    return hyperlink.URL(\n        scheme=\"https\",\n        host=\"cloud.digitalocean.com\",\n        path=(\n            \"spaces\",\n            primary_s3.bucket,\n        ),\n        query=query,\n    )\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.S3Bucket","title":"<code>S3Bucket</code>","text":"<p>             Bases: <code>Struct</code></p> <p>Represents an S3 bucket.</p> <p>Attributes:</p> Name Type Description <code>bucket</code> <code>str</code> <p>Name of an S3 bucket.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>class S3Bucket(msgspec.Struct, frozen=True):\n    \"\"\"Represents an S3 bucket.\n\n    Attributes\n    ----------\n    bucket\n        Name of an S3 bucket.\n    \"\"\"\n\n    bucket: str\n\n    def __str__(self):\n        \"\"\"Return the name of the bucket.\"\"\"\n        return str(self.bucket)\n\n    def __getitem__(self, key: str) -&gt; \"S3Object\":\n        \"\"\"Create an S3Object for this bucket with the specified key.\"\"\"\n        return S3Object(self.bucket, key)\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.S3Bucket.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Create an S3Object for this bucket with the specified key.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def __getitem__(self, key: str) -&gt; \"S3Object\":\n    \"\"\"Create an S3Object for this bucket with the specified key.\"\"\"\n    return S3Object(self.bucket, key)\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.S3Bucket.__str__","title":"<code>__str__()</code>","text":"<p>Return the name of the bucket.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def __str__(self):\n    \"\"\"Return the name of the bucket.\"\"\"\n    return str(self.bucket)\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.S3Object","title":"<code>S3Object</code>","text":"<p>             Bases: <code>Struct</code></p> <p>Represents the path to an S3 object.</p> <p>Attributes:</p> Name Type Description <code>bucket</code> <code>str</code> <p>Name of an S3 bucket.</p> <code>key</code> <code>str</code> <p>Key for an object inside the S3 bucket <code>bucket</code>.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>class S3Object(msgspec.Struct, frozen=True, order=True):\n    \"\"\"Represents the path to an S3 object.\n\n    Attributes\n    ----------\n    bucket\n        Name of an S3 bucket.\n    key\n        Key for an object inside the S3 bucket `bucket`.\n    \"\"\"\n\n    bucket: str\n    key: str\n\n    def __truediv__(self, suffix: str | Path) -&gt; \"S3Object\":\n        \"\"\"Syntactic sugar to join a suffix to the key as if both are paths.\n\n        This treats the existing key as a (pseudo)directory, so it will include a slash\n        between the original key and new suffix if there wasn't one already.\n\n        Example:\n        -------\n        &gt;&gt;&gt; s = S3Object(\"bucket\", \"key\")\n        &gt;&gt;&gt; s/\"subkey\"\n        S3Object(bucket=\"bucket\", key=\"key/subkey\")\n        \"\"\"\n        return self.joinpath(str(suffix))\n\n    def joinpath(self, *pieces: str) -&gt; \"S3Object\":\n        \"\"\"Add path pieces to the `key`.\n\n        Params\n        ------\n            pieces\n                Additional strings to include in the key.\n\n        Returns\n        -------\n            A new S3Object with `pieces` appended to the key, joined with the\n            default path separator.\n        \"\"\"\n        if not pieces:\n            raise ValueError(f\"Must have at least one piece, got: {pieces!r}\")\n\n        # Make sure there's no initial slash in suffix since joining \"/a\" and\n        # \"/b\" -&gt; \"/b\" instead of \"/a/b\".\n        sanitized_piece0 = pieces[0].removeprefix(\"/\")\n        pieces = (sanitized_piece0,) + pieces[1:]\n        path = Path(self.key)\n        new_key = path.joinpath(*pieces)\n        return S3Object(self.bucket, str(new_key))\n\n    def to_dict(self):\n        \"\"\"Convert to a dictionary of field names to field values.\"\"\"\n        return {f: getattr(self, f) for f in self.__struct_fields__}\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.S3Object.__truediv__","title":"<code>__truediv__(suffix)</code>","text":"<p>Syntactic sugar to join a suffix to the key as if both are paths.</p> <p>This treats the existing key as a (pseudo)directory, so it will include a slash between the original key and new suffix if there wasn't one already.</p> Example: <p>s = S3Object(\"bucket\", \"key\") s/\"subkey\" S3Object(bucket=\"bucket\", key=\"key/subkey\")</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def __truediv__(self, suffix: str | Path) -&gt; \"S3Object\":\n    \"\"\"Syntactic sugar to join a suffix to the key as if both are paths.\n\n    This treats the existing key as a (pseudo)directory, so it will include a slash\n    between the original key and new suffix if there wasn't one already.\n\n    Example:\n    -------\n    &gt;&gt;&gt; s = S3Object(\"bucket\", \"key\")\n    &gt;&gt;&gt; s/\"subkey\"\n    S3Object(bucket=\"bucket\", key=\"key/subkey\")\n    \"\"\"\n    return self.joinpath(str(suffix))\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.S3Object.joinpath","title":"<code>joinpath(*pieces)</code>","text":"<p>Add path pieces to the <code>key</code>.</p> Params <pre><code>pieces\n    Additional strings to include in the key.\n</code></pre> <p>Returns:</p> Type Description <code>    A new S3Object with `pieces` appended to the key, joined with the</code> <p>default path separator.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def joinpath(self, *pieces: str) -&gt; \"S3Object\":\n    \"\"\"Add path pieces to the `key`.\n\n    Params\n    ------\n        pieces\n            Additional strings to include in the key.\n\n    Returns\n    -------\n        A new S3Object with `pieces` appended to the key, joined with the\n        default path separator.\n    \"\"\"\n    if not pieces:\n        raise ValueError(f\"Must have at least one piece, got: {pieces!r}\")\n\n    # Make sure there's no initial slash in suffix since joining \"/a\" and\n    # \"/b\" -&gt; \"/b\" instead of \"/a/b\".\n    sanitized_piece0 = pieces[0].removeprefix(\"/\")\n    pieces = (sanitized_piece0,) + pieces[1:]\n    path = Path(self.key)\n    new_key = path.joinpath(*pieces)\n    return S3Object(self.bucket, str(new_key))\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.S3Object.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to a dictionary of field names to field values.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def to_dict(self):\n    \"\"\"Convert to a dictionary of field names to field values.\"\"\"\n    return {f: getattr(self, f) for f in self.__struct_fields__}\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Tracker","title":"<code>Tracker</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A single, logged piece of computation.</p> <p>This version of the class is abstract to specify the interface.</p> Source code in <code>aeromancy/tracker.py</code> <pre><code>class Tracker(ABC):\n    \"\"\"A single, logged piece of computation.\n\n    This version of the class is abstract to specify the interface.\n    \"\"\"\n\n    def __init__(\n        self,\n        project_name: str,\n        config: dict | None = None,\n        job_type: str | None = None,\n        job_group: str | None = None,\n    ):\n        \"\"\"Create a Tracker.\n\n        Several parameters are purely for organization purposes. The hierarchy\n        is essentially:\n\n            project_name\n                job_group\n                    job_type\n                        (individual run)\n\n        Parameters\n        ----------\n        project_name\n            Name of the project, should correspond to a W&amp;B project.\n        config, optional\n            Input parameters to a task. For ML, these include hyperparameters.\n            For other tasks, these can include things such as command line\n            flags.\n        job_type, optional\n            Typically used to describe the action of a specific task (e.g.,\n            \"munge\", \"evaluate\")\n        job_group, optional\n            Typically used to describe the general goal of a group of tasks\n            (e.g., \"build\", \"model\")\n        \"\"\"\n        self.project_name = project_name\n        self.config = config\n        self.job_type = job_type\n        self.job_group = job_group\n\n    @abstractmethod\n    def __enter__(self):\n        \"\"\"Use this Tracker as a context manager.\n\n        This should be run before running the code to track.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def __exit__(self, exctype, excinst, exctb) -&gt; bool:\n        \"\"\"Finish using this Tracker as a context manager.\n\n        This should be run after running the code to track.\n        Parameters and return values are standard for context managers.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def declare_output(\n        self,\n        name: str,\n        local_filenames: Sequence[Path],\n        s3_destination: S3Object,\n        artifact_type: str,\n        strip_prefix: Path | None = None,\n        metadata: dict | None = None,\n    ) -&gt; AeromancyArtifact:\n        \"\"\"Declare and store local files as associated artifacts.\n\n        These are uploaded and versioned on S3 and versioned on W&amp;B.\n\n        Parameters\n        ----------\n        name\n            Name for the output artifact.\n        local_filenames\n            Paths to local files to be stored and associated with the artifact.\n        s3_destination\n            Where to store the artifacts on S3 (bucket and prefix for keys).\n            Actual keys will be combined with the filenames in\n            `local_filename_or_filenames`.\n        artifact_type, optional\n            Approximate type of the artifact, typically used as a human readable\n            extension (e.g., \"dataset\", \"predictions\", \"metadata\").\n        strip_prefix, optional\n            Parts of the local filenames which should not be part of the\n            structure when copied to S3. For example, if you want to store a\n            file `/tmp/results.txt` but exclude `/tmp/`, you'd set\n            `strip_prefix=Path('/tmp')`.\n        metadata\n            Any extra information to be associated with the artifact.\n\n        Returns\n        -------\n            `AeromancyArtifact` representing this output.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def declare_input(\n        self,\n        artifact: AeromancyArtifact | str,\n        use_as: str | None = None,\n    ) -&gt; Sequence[Path]:\n        \"\"\"Declare that this run depends on an existing artifact.\n\n        If needed, this will fetch and catch the corresponding files for the artifact.\n\n        Parameters\n        ----------\n        artifact\n            An existing AeromancyArtifact or a W&amp;B full name. A Weights &amp; Biases\n            full name is obtained from clicking the \"Full name\" field\n            in the Version overview for an artifact.\n        use_as, optional\n            Additional metadata to track how this is being used.\n\n        Returns\n        -------\n            Local paths to the artifact.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def log(self, metrics: dict[str, Any]) -&gt; None:\n        \"\"\"Record a set of metrics to be associated with this run.\n\n        Parameters\n        ----------\n        metrics\n            Dictionary of string to any type of object that W&amp;B will accept.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Tracker.__enter__","title":"<code>__enter__()</code>  <code>abstractmethod</code>","text":"<p>Use this Tracker as a context manager.</p> <p>This should be run before running the code to track.</p> Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef __enter__(self):\n    \"\"\"Use this Tracker as a context manager.\n\n    This should be run before running the code to track.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Tracker.__exit__","title":"<code>__exit__(exctype, excinst, exctb)</code>  <code>abstractmethod</code>","text":"<p>Finish using this Tracker as a context manager.</p> <p>This should be run after running the code to track. Parameters and return values are standard for context managers.</p> Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef __exit__(self, exctype, excinst, exctb) -&gt; bool:\n    \"\"\"Finish using this Tracker as a context manager.\n\n    This should be run after running the code to track.\n    Parameters and return values are standard for context managers.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Tracker.__init__","title":"<code>__init__(project_name, config=None, job_type=None, job_group=None)</code>","text":"<p>Create a Tracker.</p> <p>Several parameters are purely for organization purposes. The hierarchy is essentially:</p> <pre><code>project_name\n    job_group\n        job_type\n            (individual run)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of the project, should correspond to a W&amp;B project.</p> required <code>config</code> <code>dict | None</code> <p>Input parameters to a task. For ML, these include hyperparameters. For other tasks, these can include things such as command line flags.</p> <code>None</code> <code>optional</code> <code>dict | None</code> <p>Input parameters to a task. For ML, these include hyperparameters. For other tasks, these can include things such as command line flags.</p> <code>None</code> <code>job_type</code> <code>str | None</code> <p>Typically used to describe the action of a specific task (e.g., \"munge\", \"evaluate\")</p> <code>None</code> <code>optional</code> <code>str | None</code> <p>Typically used to describe the action of a specific task (e.g., \"munge\", \"evaluate\")</p> <code>None</code> <code>job_group</code> <code>str | None</code> <p>Typically used to describe the general goal of a group of tasks (e.g., \"build\", \"model\")</p> <code>None</code> <code>optional</code> <code>str | None</code> <p>Typically used to describe the general goal of a group of tasks (e.g., \"build\", \"model\")</p> <code>None</code> Source code in <code>aeromancy/tracker.py</code> <pre><code>def __init__(\n    self,\n    project_name: str,\n    config: dict | None = None,\n    job_type: str | None = None,\n    job_group: str | None = None,\n):\n    \"\"\"Create a Tracker.\n\n    Several parameters are purely for organization purposes. The hierarchy\n    is essentially:\n\n        project_name\n            job_group\n                job_type\n                    (individual run)\n\n    Parameters\n    ----------\n    project_name\n        Name of the project, should correspond to a W&amp;B project.\n    config, optional\n        Input parameters to a task. For ML, these include hyperparameters.\n        For other tasks, these can include things such as command line\n        flags.\n    job_type, optional\n        Typically used to describe the action of a specific task (e.g.,\n        \"munge\", \"evaluate\")\n    job_group, optional\n        Typically used to describe the general goal of a group of tasks\n        (e.g., \"build\", \"model\")\n    \"\"\"\n    self.project_name = project_name\n    self.config = config\n    self.job_type = job_type\n    self.job_group = job_group\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Tracker.declare_input","title":"<code>declare_input(artifact, use_as=None)</code>  <code>abstractmethod</code>","text":"<p>Declare that this run depends on an existing artifact.</p> <p>If needed, this will fetch and catch the corresponding files for the artifact.</p> <p>Parameters:</p> Name Type Description Default <code>artifact</code> <code>AeromancyArtifact | str</code> <p>An existing AeromancyArtifact or a W&amp;B full name. A Weights &amp; Biases full name is obtained from clicking the \"Full name\" field in the Version overview for an artifact.</p> required <code>use_as</code> <code>str | None</code> <p>Additional metadata to track how this is being used.</p> <code>None</code> <code>optional</code> <code>str | None</code> <p>Additional metadata to track how this is being used.</p> <code>None</code> <p>Returns:</p> Type Description <code>    Local paths to the artifact.</code> Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef declare_input(\n    self,\n    artifact: AeromancyArtifact | str,\n    use_as: str | None = None,\n) -&gt; Sequence[Path]:\n    \"\"\"Declare that this run depends on an existing artifact.\n\n    If needed, this will fetch and catch the corresponding files for the artifact.\n\n    Parameters\n    ----------\n    artifact\n        An existing AeromancyArtifact or a W&amp;B full name. A Weights &amp; Biases\n        full name is obtained from clicking the \"Full name\" field\n        in the Version overview for an artifact.\n    use_as, optional\n        Additional metadata to track how this is being used.\n\n    Returns\n    -------\n        Local paths to the artifact.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Tracker.declare_output","title":"<code>declare_output(name, local_filenames, s3_destination, artifact_type, strip_prefix=None, metadata=None)</code>  <code>abstractmethod</code>","text":"<p>Declare and store local files as associated artifacts.</p> <p>These are uploaded and versioned on S3 and versioned on W&amp;B.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the output artifact.</p> required <code>local_filenames</code> <code>Sequence[Path]</code> <p>Paths to local files to be stored and associated with the artifact.</p> required <code>s3_destination</code> <code>S3Object</code> <p>Where to store the artifacts on S3 (bucket and prefix for keys). Actual keys will be combined with the filenames in <code>local_filename_or_filenames</code>.</p> required <code>artifact_type</code> <code>str</code> <p>Approximate type of the artifact, typically used as a human readable extension (e.g., \"dataset\", \"predictions\", \"metadata\").</p> required <code>optional</code> <code>str</code> <p>Approximate type of the artifact, typically used as a human readable extension (e.g., \"dataset\", \"predictions\", \"metadata\").</p> required <code>strip_prefix</code> <code>Path | None</code> <p>Parts of the local filenames which should not be part of the structure when copied to S3. For example, if you want to store a file <code>/tmp/results.txt</code> but exclude <code>/tmp/</code>, you'd set <code>strip_prefix=Path('/tmp')</code>.</p> <code>None</code> <code>optional</code> <code>Path | None</code> <p>Parts of the local filenames which should not be part of the structure when copied to S3. For example, if you want to store a file <code>/tmp/results.txt</code> but exclude <code>/tmp/</code>, you'd set <code>strip_prefix=Path('/tmp')</code>.</p> <code>None</code> <code>metadata</code> <code>dict | None</code> <p>Any extra information to be associated with the artifact.</p> <code>None</code> <p>Returns:</p> Type Description <code>    `AeromancyArtifact` representing this output.</code> Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef declare_output(\n    self,\n    name: str,\n    local_filenames: Sequence[Path],\n    s3_destination: S3Object,\n    artifact_type: str,\n    strip_prefix: Path | None = None,\n    metadata: dict | None = None,\n) -&gt; AeromancyArtifact:\n    \"\"\"Declare and store local files as associated artifacts.\n\n    These are uploaded and versioned on S3 and versioned on W&amp;B.\n\n    Parameters\n    ----------\n    name\n        Name for the output artifact.\n    local_filenames\n        Paths to local files to be stored and associated with the artifact.\n    s3_destination\n        Where to store the artifacts on S3 (bucket and prefix for keys).\n        Actual keys will be combined with the filenames in\n        `local_filename_or_filenames`.\n    artifact_type, optional\n        Approximate type of the artifact, typically used as a human readable\n        extension (e.g., \"dataset\", \"predictions\", \"metadata\").\n    strip_prefix, optional\n        Parts of the local filenames which should not be part of the\n        structure when copied to S3. For example, if you want to store a\n        file `/tmp/results.txt` but exclude `/tmp/`, you'd set\n        `strip_prefix=Path('/tmp')`.\n    metadata\n        Any extra information to be associated with the artifact.\n\n    Returns\n    -------\n        `AeromancyArtifact` representing this output.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.Tracker.log","title":"<code>log(metrics)</code>  <code>abstractmethod</code>","text":"<p>Record a set of metrics to be associated with this run.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>dict[str, Any]</code> <p>Dictionary of string to any type of object that W&amp;B will accept.</p> required Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef log(self, metrics: dict[str, Any]) -&gt; None:\n    \"\"\"Record a set of metrics to be associated with this run.\n\n    Parameters\n    ----------\n    metrics\n        Dictionary of string to any type of object that W&amp;B will accept.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.aeromancy_click_options","title":"<code>aeromancy_click_options(function)</code>","text":"<p>Wrap <code>function</code> with all Click options for Aeromancy.</p> <p>This is intended to wrap an <code>aeromain</code> function.</p> Source code in <code>aeromancy/click_options.py</code> <pre><code>def aeromancy_click_options(function):\n    \"\"\"Wrap `function` with all Click options for Aeromancy.\n\n    This is intended to wrap an `aeromain` function.\n    \"\"\"\n    # NOTE: Keep in sync with OPTION_GROUPS.\n\n    @click.option(\n        \"-o\",\n        \"--only\",\n        default=None,\n        type=str,\n        metavar=\"SUBSTRS\",\n        help=\"If set: comma-separated list of substrings. We'll only run jobs which \"\n        \"match at least one of these (in dependency order).\",\n    )\n    @click.option(\n        \"--graph\",\n        is_flag=True,\n        help=\"If set: show a graph of job dependencies and exit.\",\n    )\n    @click.option(\n        \"--list-actions\",\n        \"--list\",\n        is_flag=True,\n        help=\"If set: show a list of all job names and exit.\",\n    )\n    @runner_click_options\n    @functools.wraps(function)\n    def wrapper_aeromancy_options(*args, **kwargs):\n        return function(*args, **kwargs)\n\n    return wrapper_aeromancy_options\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.bailout","title":"<code>bailout()</code>","text":"<p>Exit Aeromancy immediately (for quick debugging).</p> <p>This is primarily intended for <code>--dev</code> mode where it will avoid the extensive tracebacks we normally show. If run outside of <code>--dev</code> mode, it will still exit Aeromancy (but consider a more descriptive error).</p> Source code in <code>aeromancy/fake_tracker.py</code> <pre><code>def bailout():\n    \"\"\"Exit Aeromancy immediately (for quick debugging).\n\n    This is primarily intended for `--dev` mode where it will avoid the\n    extensive tracebacks we normally show. If run outside of `--dev` mode, it\n    will still exit Aeromancy (but consider a more descriptive error).\n    \"\"\"\n    raise _BailoutError\n</code></pre>"},{"location":"reference/aeromancy/#aeromancy.get_runtime_environment","title":"<code>get_runtime_environment()</code>","text":"<p>Fetch the <code>RuntimeEnvironment</code> global.</p> <p>This is created on demand and reuses existing instances.</p> Source code in <code>aeromancy/runtime_environment.py</code> <pre><code>def get_runtime_environment() -&gt; RuntimeEnvironment:\n    \"\"\"Fetch the `RuntimeEnvironment` global.\n\n    This is created on demand and reuses existing instances.\n    \"\"\"\n    global _runtime_environment\n    if not _runtime_environment:\n        _runtime_environment = RuntimeEnvironment()\n    return _runtime_environment\n</code></pre>"},{"location":"reference/aeromancy/action/","title":"action","text":"<p>Action objects are the core piece of trackable computation in Aeromancy.</p>"},{"location":"reference/aeromancy/action/#aeromancy.action.Action","title":"<code>Action</code>","text":"<p>A specific piece of work to track.</p> <p>This includes the code to run, artifacts it depends on, and artifacts it produces. For organizational purposes, they can fill in class variables:</p> <ul> <li><code>job_type</code></li> <li><code>job_group</code></li> </ul> <p>(<code>job_group</code> is more general than <code>job_type</code>. Semantics are up to the project design and <code>Tracker</code> backend.)</p> Source code in <code>aeromancy/action.py</code> <pre><code>class Action:\n    \"\"\"A specific piece of work to track.\n\n    This includes the code to run, artifacts it depends on, and artifacts it\n    produces. For organizational purposes, they can fill in class variables:\n\n    - `job_type`\n    - `job_group`\n\n    (`job_group` is more general than `job_type`. Semantics are up to the\n    project design and `Tracker` backend.)\n    \"\"\"\n\n    # Properties for subclasses to fill in.\n    job_type: str | None = None\n    job_group: str | None = None\n\n    def __init__(self, parents: list[\"Action\"], **config):\n        \"\"\"Create an `Action`.\n\n        Parameters\n        ----------\n        parents\n            `Action`s that this `Action` depends on. These must be run first.\n        config\n            Any `Action`-specific configuration. If the `Action` were a function\n            call, these would be its parameters (e.g., hyperparameters for many\n            ML algorithms).\n        \"\"\"\n        self.config = config\n        self.parents = parents\n        self._tracker_class = WandbTracker\n        self._project_name = None\n\n    def outputs(self) -&gt; list[str]:\n        \"\"\"Describe what this `Action` will produce after being run.\n\n        Must be overridden.\n\n        Returns\n        -------\n            List of artifact names that this `Action` will produce.\n        \"\"\"\n        raise NotImplementedError\n\n    def run(self, tracker: Tracker) -&gt; None:\n        \"\"\"Execute this action.\n\n        This logic is Action-specific and must be overridden by subclasses.\n\n        Parameters\n        ----------\n        tracker\n            An Aeromancy `Tracker` for this task.\n        \"\"\"\n        raise NotImplementedError\n\n    # TODO: should return outputs()? Then we can store them between runs.\n    def _run(self) -&gt; None:\n        \"\"\"Actual run method that task runners call.\n\n        Should not be called directly.\n        \"\"\"\n        if self._project_name is None:\n            raise ValueError(\n                f\"Must set project_name on your Action class: {self.__class__}\",\n            )\n\n        with self._tracker_class(\n            job_type=self.job_type,\n            job_group=self.job_group,\n            config=self.config,\n            project_name=self._project_name,\n        ) as tracker:\n            self.run(tracker)\n\n    def _set_tracker(self, tracker_class: type[Tracker]) -&gt; None:\n        \"\"\"Set a different class to use for tracking.\n\n        This should only be called under special circumstances (e.g., testing\n        environments, offline mode).\n        \"\"\"\n        self._tracker_class = tracker_class\n\n    def get_io(self, resolve_outputs=False) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Get inputs and outputs for this `Action`.\n\n        Parameters\n        ----------\n        resolve_outputs, optional\n            If set, output artifacts will be versioned\n\n        Returns\n        -------\n            Tuple with names of (input artifacts, output artifacts)\n        \"\"\"\n        parent_outputs = []\n        for parent in self.parents:\n            parent_outputs.extend(parent.outputs())\n        full_inputs = [\n            WandbArtifactName.resolve_artifact_name(\n                artifact_name,\n                default_project_name=self._project_name,\n            )\n            for artifact_name in parent_outputs\n        ]\n        full_outputs = self.outputs()\n        if resolve_outputs:\n            full_outputs = [\n                WandbArtifactName.resolve_artifact_name(\n                    artifact_name,\n                    default_project_name=self._project_name,\n                )\n                for artifact_name in full_outputs\n            ]\n        return (full_inputs, full_outputs)\n\n    def _set_runtime_properties(self, project_name: str, skip: bool):\n        \"\"\"Set properties that we won't know until we're ready to run.\"\"\"\n        self._skip = skip\n        self._project_name = project_name\n\n    skip = property(lambda self: self._skip, doc=\"Whether this action should be run\")\n</code></pre>"},{"location":"reference/aeromancy/action/#aeromancy.action.Action.__init__","title":"<code>__init__(parents, **config)</code>","text":"<p>Create an <code>Action</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parents</code> <code>list[Action]</code> <p><code>Action</code>s that this <code>Action</code> depends on. These must be run first.</p> required <code>config</code> <p>Any <code>Action</code>-specific configuration. If the <code>Action</code> were a function call, these would be its parameters (e.g., hyperparameters for many ML algorithms).</p> <code>{}</code> Source code in <code>aeromancy/action.py</code> <pre><code>def __init__(self, parents: list[\"Action\"], **config):\n    \"\"\"Create an `Action`.\n\n    Parameters\n    ----------\n    parents\n        `Action`s that this `Action` depends on. These must be run first.\n    config\n        Any `Action`-specific configuration. If the `Action` were a function\n        call, these would be its parameters (e.g., hyperparameters for many\n        ML algorithms).\n    \"\"\"\n    self.config = config\n    self.parents = parents\n    self._tracker_class = WandbTracker\n    self._project_name = None\n</code></pre>"},{"location":"reference/aeromancy/action/#aeromancy.action.Action.get_io","title":"<code>get_io(resolve_outputs=False)</code>","text":"<p>Get inputs and outputs for this <code>Action</code>.</p> <p>Parameters:</p> Name Type Description Default <code>resolve_outputs</code> <p>If set, output artifacts will be versioned</p> <code>False</code> <code>optional</code> <p>If set, output artifacts will be versioned</p> <code>False</code> <p>Returns:</p> Type Description <code>    Tuple with names of (input artifacts, output artifacts)</code> Source code in <code>aeromancy/action.py</code> <pre><code>def get_io(self, resolve_outputs=False) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Get inputs and outputs for this `Action`.\n\n    Parameters\n    ----------\n    resolve_outputs, optional\n        If set, output artifacts will be versioned\n\n    Returns\n    -------\n        Tuple with names of (input artifacts, output artifacts)\n    \"\"\"\n    parent_outputs = []\n    for parent in self.parents:\n        parent_outputs.extend(parent.outputs())\n    full_inputs = [\n        WandbArtifactName.resolve_artifact_name(\n            artifact_name,\n            default_project_name=self._project_name,\n        )\n        for artifact_name in parent_outputs\n    ]\n    full_outputs = self.outputs()\n    if resolve_outputs:\n        full_outputs = [\n            WandbArtifactName.resolve_artifact_name(\n                artifact_name,\n                default_project_name=self._project_name,\n            )\n            for artifact_name in full_outputs\n        ]\n    return (full_inputs, full_outputs)\n</code></pre>"},{"location":"reference/aeromancy/action/#aeromancy.action.Action.outputs","title":"<code>outputs()</code>","text":"<p>Describe what this <code>Action</code> will produce after being run.</p> <p>Must be overridden.</p> <p>Returns:</p> Type Description <code>    List of artifact names that this `Action` will produce.</code> Source code in <code>aeromancy/action.py</code> <pre><code>def outputs(self) -&gt; list[str]:\n    \"\"\"Describe what this `Action` will produce after being run.\n\n    Must be overridden.\n\n    Returns\n    -------\n        List of artifact names that this `Action` will produce.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/action/#aeromancy.action.Action.run","title":"<code>run(tracker)</code>","text":"<p>Execute this action.</p> <p>This logic is Action-specific and must be overridden by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>tracker</code> <code>Tracker</code> <p>An Aeromancy <code>Tracker</code> for this task.</p> required Source code in <code>aeromancy/action.py</code> <pre><code>def run(self, tracker: Tracker) -&gt; None:\n    \"\"\"Execute this action.\n\n    This logic is Action-specific and must be overridden by subclasses.\n\n    Parameters\n    ----------\n    tracker\n        An Aeromancy `Tracker` for this task.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/action_builder/","title":"action_builder","text":"<p>Build a computation graph over Action objects.</p>"},{"location":"reference/aeromancy/action_builder/#aeromancy.action_builder.ActionBuilder","title":"<code>ActionBuilder</code>","text":"<p>Sets up and runs (via pydoit) a computation graph over <code>Action</code>s.</p> <p>Subclasses must implement <code>build_actions</code>.</p> Source code in <code>aeromancy/action_builder.py</code> <pre><code>class ActionBuilder:\n    \"\"\"Sets up and runs (via pydoit) a computation graph over `Action`s.\n\n    Subclasses must implement `build_actions`.\n    \"\"\"\n\n    def __init__(self, project_name):\n        \"\"\"Create an `ActionBuilder`.\n\n        Parameters\n        ----------\n        project_name\n            The project that the `Action`s created by this should live in.\n        \"\"\"\n        self._project_name = project_name\n\n    def build_actions(self) -&gt; list[Action]:\n        \"\"\"Produce a list of `Action`s to run.\n\n        This must be implemented by subclasses.\n\n        For each action, you should use the `add_action` helper to add it to a\n        local list of `Action`s. This will help you set internal states on\n        `Action`s (e.g., if an action should be skipped under the current\n        configuration). For example:\n\n        ```\n            def build_actions(self):\n                actions = []\n                a1 = self.add_action(actions, Action1(), skip=True)\n                a2 = self.add_action(actions, Action2(parents=[a1]), skip=False)\n                a3 = self.add_action(actions, Action3(parents=[a1]), skip=False)\n                a4 = self.add_action(actions, Action4(parents=[a2, a3]), skip=False)\n                return actions\n        ```\n\n        Returns\n        -------\n            List of `Actions` to run.\n        \"\"\"\n        raise NotImplementedError\n\n    def add_action(\n        self,\n        actions: list[Action],\n        action: ActionType,\n        skip: bool = False,\n    ) -&gt; ActionType:\n        \"\"\"Add an `Action` while setting run state for the `Action`.\n\n        See `build_actions` for more details and example usage.\n\n        Parameters\n        ----------\n        actions\n            A growing list of `Action`s, built up in a `build_actions` method\n        action\n            `Action` to add to `actions`\n        skip, optional\n            Whether the `action` should not be run, by default False\n\n        Returns\n        -------\n            The `Action` passed as `action`, with additional run state added\n        \"\"\"\n        action._set_runtime_properties(self._project_name, skip=skip)\n        actions.append(action)\n        return action\n\n    def to_runner(self) -&gt; ActionRunner:\n        \"\"\"Convert to an `ActionRunner` for running these actions.\n\n        Returns\n        -------\n            An `ActionRunner` which can run the `Actions` specified in\n            `build_actions` using pydoit.\n        \"\"\"\n        return ActionRunner(self.build_actions())\n</code></pre>"},{"location":"reference/aeromancy/action_builder/#aeromancy.action_builder.ActionBuilder.__init__","title":"<code>__init__(project_name)</code>","text":"<p>Create an <code>ActionBuilder</code>.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <p>The project that the <code>Action</code>s created by this should live in.</p> required Source code in <code>aeromancy/action_builder.py</code> <pre><code>def __init__(self, project_name):\n    \"\"\"Create an `ActionBuilder`.\n\n    Parameters\n    ----------\n    project_name\n        The project that the `Action`s created by this should live in.\n    \"\"\"\n    self._project_name = project_name\n</code></pre>"},{"location":"reference/aeromancy/action_builder/#aeromancy.action_builder.ActionBuilder.add_action","title":"<code>add_action(actions, action, skip=False)</code>","text":"<p>Add an <code>Action</code> while setting run state for the <code>Action</code>.</p> <p>See <code>build_actions</code> for more details and example usage.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list[Action]</code> <p>A growing list of <code>Action</code>s, built up in a <code>build_actions</code> method</p> required <code>action</code> <code>ActionType</code> <p><code>Action</code> to add to <code>actions</code></p> required <code>skip</code> <code>bool</code> <p>Whether the <code>action</code> should not be run, by default False</p> <code>False</code> <code>optional</code> <code>bool</code> <p>Whether the <code>action</code> should not be run, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>    The `Action` passed as `action`, with additional run state added</code> Source code in <code>aeromancy/action_builder.py</code> <pre><code>def add_action(\n    self,\n    actions: list[Action],\n    action: ActionType,\n    skip: bool = False,\n) -&gt; ActionType:\n    \"\"\"Add an `Action` while setting run state for the `Action`.\n\n    See `build_actions` for more details and example usage.\n\n    Parameters\n    ----------\n    actions\n        A growing list of `Action`s, built up in a `build_actions` method\n    action\n        `Action` to add to `actions`\n    skip, optional\n        Whether the `action` should not be run, by default False\n\n    Returns\n    -------\n        The `Action` passed as `action`, with additional run state added\n    \"\"\"\n    action._set_runtime_properties(self._project_name, skip=skip)\n    actions.append(action)\n    return action\n</code></pre>"},{"location":"reference/aeromancy/action_builder/#aeromancy.action_builder.ActionBuilder.build_actions","title":"<code>build_actions()</code>","text":"<p>Produce a list of <code>Action</code>s to run.</p> <p>This must be implemented by subclasses.</p> <p>For each action, you should use the <code>add_action</code> helper to add it to a local list of <code>Action</code>s. This will help you set internal states on <code>Action</code>s (e.g., if an action should be skipped under the current configuration). For example:</p> <pre><code>    def build_actions(self):\n        actions = []\n        a1 = self.add_action(actions, Action1(), skip=True)\n        a2 = self.add_action(actions, Action2(parents=[a1]), skip=False)\n        a3 = self.add_action(actions, Action3(parents=[a1]), skip=False)\n        a4 = self.add_action(actions, Action4(parents=[a2, a3]), skip=False)\n        return actions\n</code></pre> <p>Returns:</p> Type Description <code>    List of `Actions` to run.</code> Source code in <code>aeromancy/action_builder.py</code> <pre><code>def build_actions(self) -&gt; list[Action]:\n    \"\"\"Produce a list of `Action`s to run.\n\n    This must be implemented by subclasses.\n\n    For each action, you should use the `add_action` helper to add it to a\n    local list of `Action`s. This will help you set internal states on\n    `Action`s (e.g., if an action should be skipped under the current\n    configuration). For example:\n\n    ```\n        def build_actions(self):\n            actions = []\n            a1 = self.add_action(actions, Action1(), skip=True)\n            a2 = self.add_action(actions, Action2(parents=[a1]), skip=False)\n            a3 = self.add_action(actions, Action3(parents=[a1]), skip=False)\n            a4 = self.add_action(actions, Action4(parents=[a2, a3]), skip=False)\n            return actions\n    ```\n\n    Returns\n    -------\n        List of `Actions` to run.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/action_builder/#aeromancy.action_builder.ActionBuilder.to_runner","title":"<code>to_runner()</code>","text":"<p>Convert to an <code>ActionRunner</code> for running these actions.</p> <p>Returns:</p> Type Description <code>    An `ActionRunner` which can run the `Actions` specified in</code> <p><code>build_actions</code> using pydoit.</p> Source code in <code>aeromancy/action_builder.py</code> <pre><code>def to_runner(self) -&gt; ActionRunner:\n    \"\"\"Convert to an `ActionRunner` for running these actions.\n\n    Returns\n    -------\n        An `ActionRunner` which can run the `Actions` specified in\n        `build_actions` using pydoit.\n    \"\"\"\n    return ActionRunner(self.build_actions())\n</code></pre>"},{"location":"reference/aeromancy/action_runner/","title":"action_runner","text":"<p>Execute a computation graph over Action objects using pydoit.</p>"},{"location":"reference/aeromancy/action_runner/#aeromancy.action_runner.ActionRunner","title":"<code>ActionRunner</code>","text":"<p>             Bases: <code>TaskLoader2</code></p> <p>Bridge between ActionBuilder and pydoit.</p> <p>Under the hood, this is a pydoit <code>TaskLoader2</code>. The <code>run_actions</code> convenience method is the main entry point for running these tasks via pydoit.</p> Source code in <code>aeromancy/action_runner.py</code> <pre><code>class ActionRunner(TaskLoader2):\n    \"\"\"Bridge between ActionBuilder and pydoit.\n\n    Under the hood, this is a pydoit `TaskLoader2`. The `run_actions`\n    convenience method is the main entry point for running these tasks via\n    pydoit.\n    \"\"\"\n\n    def __init__(self, actions: list[Action]):\n        \"\"\"Create a runner for already constructed `Action`s.\n\n        Parameters\n        ----------\n        actions\n            `Action`s to run.\n        \"\"\"\n        self.actions = actions\n        self.job_name_filter = None\n\n    @override\n    def load_doit_config(self):\n        # verbosity=2 makes doit not mess with stdout/stderr.\n        return {\n            \"verbosity\": 2,\n            \"reporter\": RichConsoleReporter,\n        }\n\n    @override\n    def load_tasks(self, **unused) -&gt; list[DoitTask]:\n        return [self._convert_action_to_doittask(action) for action in self.actions]\n\n    def _convert_action_to_doittask(\n        self,\n        action: Action,\n    ) -&gt; DoitTask:\n        if get_runtime_environment().dev_mode:\n            action._set_tracker(FakeTracker)\n\n        outputs = action.outputs()\n        skip = action.skip\n\n        if self.job_name_filter is not None:\n            description = f\"{action.job_type} {' '.join(outputs)}\"\n            # Filter overrides normal skip settings.\n            skip = not self.job_name_filter(description)\n\n        task_deps = []\n        for parent in action.parents:\n            task_deps.extend(parent.outputs())\n\n        doit_task = DoitTask(\n            name=outputs[0],\n            doc=action.job_type,\n            actions=[action._run],\n            task_dep=task_deps,\n            uptodate=[skip],\n            meta={\n                \"job_type\": action.job_type,\n                \"outputs\": action.outputs(),\n            },\n            io={\"capture\": False},  # doit shouldn't mess with stdin, etc.\n        )\n\n        if self.job_name_filter is not None:\n            message = (\n                \"[white on red] NO [/white on red]\"\n                if skip\n                else \"[black on bright_green] GO [/black on bright_green]\"\n            )\n            console.log(f\"Action filter: {message} {task_to_rich_markup(doit_task)}\")\n\n        return doit_task\n\n    def _draw_graph(self):\n        dot = pydot.Dot(resolution=300)\n        for task in self.load_tasks():\n            up_to_date = task.uptodate[0][0]\n            job_type = task.meta[\"job_type\"]  # type: ignore\n            label = f\"{job_type} | {task.name}\"\n            dot.add_node(\n                pydot.Node(\n                    task.name,\n                    label=label,\n                    shape=\"record\",\n                    fontname=\"Sans-Serif\",\n                    color=\"yellow\" if up_to_date else \"green\",\n                ),\n            )\n            for parent in task.task_dep:\n                dot.add_edge(pydot.Edge(parent, task.name))\n\n        with tempfile.NamedTemporaryFile(suffix=\".png\") as dot_png_file:\n            dot.write(dot_png_file.name, format=\"png\")\n            deps_image = term_image.image.from_file(dot_png_file.name)\n            deps_image.draw()\n\n    def _list_actions(self):\n        for task in self.load_tasks():\n            rich_print(task_to_rich_markup(task))\n\n    def run_actions(\n        self,\n        only: str | None,\n        graph: bool,\n        list_actions: bool,\n        **unused_kwargs,\n    ):\n        \"\"\"Run the stored `Action`s using pydoit.\n\n        Parameters\n        ----------\n        only\n            If set, a comma-separated list of substrings to filter job names\n            against. In this case, we will only run jobs that match at least one\n            of these filters.\n        graph\n            If True, show the action dependency graph and exit.\n        list_actions\n            If True, show a list of action names and exit.\n        unused_kwargs\n            Should not be used -- this is here as part of some Click hackery to\n            show all options in the help menu.\n        \"\"\"\n        if only:\n\n            def job_name_filter(job_name):\n                for job_name_substring in only.split(\",\"):\n                    if job_name_substring.strip() in job_name:\n                        return True\n                return False\n\n            self.job_name_filter = job_name_filter\n\n        if graph:\n            self._draw_graph()\n            raise SystemExit\n\n        if list_actions:\n            self._list_actions()\n            raise SystemExit\n\n        if get_runtime_environment().dev_mode:\n            console.rule(\n                \"[red bold]DEV MODE[/red bold]\",\n                style=\"red\",\n                characters=\"\u26a0\ufe0f  \",\n            )\n\n        # Launch pydoit.\n        DoitMain(self).run([])\n</code></pre>"},{"location":"reference/aeromancy/action_runner/#aeromancy.action_runner.ActionRunner.__init__","title":"<code>__init__(actions)</code>","text":"<p>Create a runner for already constructed <code>Action</code>s.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list[Action]</code> <p><code>Action</code>s to run.</p> required Source code in <code>aeromancy/action_runner.py</code> <pre><code>def __init__(self, actions: list[Action]):\n    \"\"\"Create a runner for already constructed `Action`s.\n\n    Parameters\n    ----------\n    actions\n        `Action`s to run.\n    \"\"\"\n    self.actions = actions\n    self.job_name_filter = None\n</code></pre>"},{"location":"reference/aeromancy/action_runner/#aeromancy.action_runner.ActionRunner.run_actions","title":"<code>run_actions(only, graph, list_actions, **unused_kwargs)</code>","text":"<p>Run the stored <code>Action</code>s using pydoit.</p> <p>Parameters:</p> Name Type Description Default <code>only</code> <code>str | None</code> <p>If set, a comma-separated list of substrings to filter job names against. In this case, we will only run jobs that match at least one of these filters.</p> required <code>graph</code> <code>bool</code> <p>If True, show the action dependency graph and exit.</p> required <code>list_actions</code> <code>bool</code> <p>If True, show a list of action names and exit.</p> required <code>unused_kwargs</code> <p>Should not be used -- this is here as part of some Click hackery to show all options in the help menu.</p> <code>{}</code> Source code in <code>aeromancy/action_runner.py</code> <pre><code>def run_actions(\n    self,\n    only: str | None,\n    graph: bool,\n    list_actions: bool,\n    **unused_kwargs,\n):\n    \"\"\"Run the stored `Action`s using pydoit.\n\n    Parameters\n    ----------\n    only\n        If set, a comma-separated list of substrings to filter job names\n        against. In this case, we will only run jobs that match at least one\n        of these filters.\n    graph\n        If True, show the action dependency graph and exit.\n    list_actions\n        If True, show a list of action names and exit.\n    unused_kwargs\n        Should not be used -- this is here as part of some Click hackery to\n        show all options in the help menu.\n    \"\"\"\n    if only:\n\n        def job_name_filter(job_name):\n            for job_name_substring in only.split(\",\"):\n                if job_name_substring.strip() in job_name:\n                    return True\n            return False\n\n        self.job_name_filter = job_name_filter\n\n    if graph:\n        self._draw_graph()\n        raise SystemExit\n\n    if list_actions:\n        self._list_actions()\n        raise SystemExit\n\n    if get_runtime_environment().dev_mode:\n        console.rule(\n            \"[red bold]DEV MODE[/red bold]\",\n            style=\"red\",\n            characters=\"\u26a0\ufe0f  \",\n        )\n\n    # Launch pydoit.\n    DoitMain(self).run([])\n</code></pre>"},{"location":"reference/aeromancy/action_runner/#aeromancy.action_runner.RichConsoleReporter","title":"<code>RichConsoleReporter</code>","text":"<p>             Bases: <code>ConsoleReporter</code></p> <p>Logs pydoit events using Rich Console.</p> Source code in <code>aeromancy/action_runner.py</code> <pre><code>class RichConsoleReporter(ConsoleReporter):\n    \"\"\"Logs pydoit events using Rich Console.\"\"\"\n\n    def _draw_rule(\n        self,\n        emoji: str,\n        line_color: str,\n        message: str,\n        task: DoitTask,\n        message_style: str | None = None,\n    ):\n        message_style = line_color if message_style is None else message_style\n        console.rule(\n            f\"{emoji}[{line_color}] \u2500\u2500\u2500 [/{line_color}]\"\n            f\"[{message_style}]{message}[/{message_style}] \"\n            + task_to_rich_markup(task),\n            style=line_color,\n            align=\"left\",\n        )\n\n    @override\n    def execute_task(self, task: DoitTask):\n        self._draw_rule(\n            emoji=\"\ud83d\ude80\",\n            line_color=\"green\",\n            message=\"Running\",\n            task=task,\n        )\n\n    @override\n    def skip_uptodate(self, task: DoitTask):\n        self._draw_rule(\n            emoji=\"\u23ed\ufe0f \",  # Needs an extra space Because Unicode(tm).\n            line_color=\"yellow\",\n            message_style=\"yellow italic\",\n            message=\"Skipped\",\n            task=task,\n        )\n\n    @override\n    def add_failure(self, task: DoitTask, _):\n        self._draw_rule(\n            emoji=\"\ud83d\udca3\",\n            line_color=\"red\",\n            message=\"Task failed:\",\n            task=task,\n        )\n</code></pre>"},{"location":"reference/aeromancy/action_runner/#aeromancy.action_runner.task_to_rich_markup","title":"<code>task_to_rich_markup(task)</code>","text":"<p>Format a pydoit task for Rich Console.</p> Source code in <code>aeromancy/action_runner.py</code> <pre><code>def task_to_rich_markup(task: DoitTask):\n    \"\"\"Format a pydoit task for Rich Console.\"\"\"\n    meta = task.meta or {}\n    return f\"\\\\[[bold]{meta['job_type']}[/bold]] {meta['outputs'][0]}\"\n</code></pre>"},{"location":"reference/aeromancy/aeroview/","title":"aeroview","text":"<p>Tool for examining Aeromancy/W&amp;B artifacts.</p> <p>Run with:</p> <pre><code>shell&gt; pdm aeroview &lt;aeromancy URI&gt;\n</code></pre> <p>or:</p> <pre><code>shell&gt; pdm aeroview &lt;Weights and Biases artifact name&gt;\n</code></pre>"},{"location":"reference/aeromancy/aeroview/#aeromancy.aeroview.main","title":"<code>main(artifact_full_name)</code>","text":"<p>Display information about Weights &amp; Biases artifacts.</p> <p>ARTIFACT_FULL_NAME can be an Aeromancy URI (starts with <code>aeromancy://</code>\") or a Weights and Biases artifact name, with or without a version.</p> Source code in <code>aeromancy/aeroview.py</code> <pre><code>@click.command(context_settings=CLICK_CONTEXT_SETTINGS, no_args_is_help=True)\n@click.argument(\"artifact_full_name\")\ndef main(artifact_full_name: str) -&gt; None:\n    \"\"\"Display information about Weights &amp; Biases artifacts.\n\n    ARTIFACT_FULL_NAME can be an Aeromancy URI (starts with `aeromancy://`\") or\n    a Weights and Biases artifact name, with or without a version.\n    \"\"\"\n    s3_client = S3Client.from_env_variables()\n\n    if artifact_full_name.startswith(\"aeromancy://\") or \":\" not in artifact_full_name:\n        aeromancy_uri = hyperlink.parse(artifact_full_name)\n        view_aeromancy_uri(aeromancy_uri, s3_client)\n    else:\n        wandb_api = wandb.Api()\n        wandb_api_artifact = wandb_api.artifact(artifact_full_name)\n        inspect(wandb_api_artifact)\n        aeromancy_artifact = AeromancyArtifact.from_wandb_api_artifact(\n            wandb_api_artifact,\n        )\n        if len(aeromancy_artifact.s3) &gt; 1:\n            console.log(f\"{len(aeromancy_artifact.s3)} entries in manifest:\")\n        for s3 in aeromancy_artifact.s3:\n            view_aeromancy_uri(s3.to_aeromancy_uri(), s3_client)\n</code></pre>"},{"location":"reference/aeromancy/aeroview/#aeromancy.aeroview.view_aeromancy_uri","title":"<code>view_aeromancy_uri(aeromancy_uri, s3_client)</code>","text":"<p>Interactively view an Aeromancy artifact.</p> <p>Parameters:</p> Name Type Description Default <code>aeromancy_uri</code> <code>URL | DecodedURL</code> <p>Aeromancy URI (i.e., with \"aeromancy://\" scheme)</p> required <code>s3_client</code> <code>S3Client</code> <p>An S3 client to look up artifact files.</p> required Source code in <code>aeromancy/aeroview.py</code> <pre><code>def view_aeromancy_uri(\n    aeromancy_uri: hyperlink.URL | hyperlink.DecodedURL,\n    s3_client: S3Client,\n) -&gt; None:\n    \"\"\"Interactively view an Aeromancy artifact.\n\n    Parameters\n    ----------\n    aeromancy_uri\n        Aeromancy URI (i.e., with \"aeromancy://\" scheme)\n    s3_client\n        An S3 client to look up artifact files.\n    \"\"\"\n    console.rule(f\"URI: {aeromancy_uri}\")\n\n    s3 = VersionedS3Object.from_aeromancy_uri(aeromancy_uri)\n    local_path = s3_client.fetch(s3)\n    real_filename = Path(*aeromancy_uri.path)\n    match real_filename.suffix:\n        case \".yaml\":\n            subprocess.check_call(\n                [  # noqa: S607\n                    \"bat\",\n                    local_path,\n                    \"--file-name\",\n                    real_filename,\n                ],\n            )\n        case \".feather\":\n            artifact_df = pd.read_feather(local_path)\n            print(\"[bold]Head:[/bold]\")\n            print(artifact_df.head())\n            print()\n            print(\"[bold]Described:[/bold]\")\n            print(artifact_df.describe())\n            print()\n            print(\"[bold]Info:[/bold]\")\n            artifact_df.info()\n        case \".skops\":\n            skops.io.visualize(local_path)\n        case _:\n            console.log(f\"No viewer for {real_filename.suffix} files.\")\n</code></pre>"},{"location":"reference/aeromancy/artifacts/","title":"artifacts","text":"<p>Library for interfacing with artifacts (files stored and tracked externally).</p> <p>This is effectively a bridge between Weights and Biases artifacts and S3-backed version objects.</p>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.AeromancyArtifact","title":"<code>AeromancyArtifact</code>","text":"<p>             Bases: <code>Struct</code></p> <p>External artifact produced and/or consumed by Aeromancy <code>Action</code>s.</p> <p>This class includes information to simultaneously track external files using Weights and Biases and a S3-compatible storage provider.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The artifact name (should comply with Weights and Biases naming scheme, see <code>validate_wandb_artifact_string</code>).</p> <code>artifact_type</code> <code>str</code> <p>Free text string to be associated with the artifact (should comply with Weights and Biases naming scheme, see <code>validate_wandb_artifact_string</code>). Semantics are up to project-specific conventions, but recommendation is a simple human-readable description of the extension.</p> <code>s3</code> <code>list[VersionedS3Object]</code> <p>S3 references for the contents of this artifact.</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>class AeromancyArtifact(msgspec.Struct):\n    \"\"\"External artifact produced and/or consumed by Aeromancy `Action`s.\n\n    This class includes information to simultaneously track external files using\n    Weights and Biases and a S3-compatible storage provider.\n\n    Attributes\n    ----------\n    name\n        The artifact name (should comply with Weights and Biases naming scheme,\n        see `validate_wandb_artifact_string`).\n    artifact_type\n        Free text string to be associated with the artifact (should comply with\n        Weights and Biases naming scheme, see `validate_wandb_artifact_string`).\n        Semantics are up to project-specific conventions, but recommendation is\n        a simple human-readable description of the extension.\n    s3\n        S3 references for the contents of this artifact.\n    \"\"\"\n\n    name: str\n    artifact_type: str\n    s3: list[VersionedS3Object]\n\n    def __post_init__(self):\n        \"\"\"Validate our inputs.\"\"\"\n        # We don't know for sure that Weights and Biases holds artifact type\n        # strings subject to the same constraints as artifact name, but we'll\n        # enforce it here out of paranoia.\n        _validate_wandb_artifact_string(self.name, \"artifact\")\n        _validate_wandb_artifact_string(self.artifact_type, \"artifact type\")\n\n    @classmethod\n    def from_wandb_api_artifact(cls, wandb_api_artifact: WandbApiArtifact):\n        \"\"\"Create an `AeromancyArtifact` from a Weights and Biases API artifact.\n\n        Parameters\n        ----------\n        wandb_api_artifact\n            Artifact to convert. Note that this is a Weights and Biases *API*\n            Artifact, which is distinct from the typical Weights and Biases\n            Artifact.\n\n        Returns\n        -------\n            An `AeromancyArtifact` corresponding to `wandb_api_artifact`\n        \"\"\"\n        s3_objects = []\n        for _, manifest_value in sorted(wandb_api_artifact.manifest.entries.items()):\n            if manifest_value.ref is None:\n                raise ValueError(\"No URI associated with manifest entry\")\n            aeromancy_uri = hyperlink.parse(manifest_value.ref)\n            s3 = VersionedS3Object.from_aeromancy_uri(aeromancy_uri)\n            s3_objects.append(s3)\n\n        artifact_type = wandb_api_artifact.type\n        artifact_name = WandbArtifactName.parse(wandb_api_artifact.name)\n\n        return AeromancyArtifact(\n            s3=s3_objects,\n            artifact_type=artifact_type,\n            name=artifact_name.artifact_name,\n        )\n\n    def as_wandb_artifact(\n        self,\n        metadata: dict | None = None,\n    ) -&gt; wandb.Artifact:\n        \"\"\"Convert this into a Weights and Biases `Artifact`.\n\n        Parameters\n        ----------\n        metadata, optional\n            Optional fields to associate with the `Artifact`. These will be\n            stored and accessible on Weights and Biases.\n\n        Returns\n        -------\n            This object represented as a Weights and Biases `Artifact`.\n        \"\"\"\n        primary_s3 = self.s3[0]\n        # Metadata here is intended as a debugging aid.\n        # We make a copy since we're going to modify it and the caller doesn't expect it\n        # to change.\n        metadata = dict(metadata or {})\n        metadata.update(\n            primary_s3_key=primary_s3.key,\n            primary_s3_bucket=primary_s3.bucket,\n            primary_s3_version=primary_s3.version_id,\n            # For viewing this Artifact on an S3 viewer webpage.\n            viewer_url=self.to_s3_viewer_url(),\n            num_files=len(self.s3),\n        )\n\n        description = f\"{primary_s3.bucket}/{primary_s3.key}\"\n        if len(self.s3) &gt; 1:\n            description = f\"{description} (+{len(self.s3) - 1} others)\"\n        artifact = wandb.Artifact(\n            name=self.name,\n            description=description,\n            type=self.artifact_type,\n            metadata=metadata,\n        )\n        # We need an external reference so W&amp;B knows when it changes.\n        for s3 in self.s3:\n            artifact.add_reference(name=s3.key, uri=str(s3.to_aeromancy_uri()))\n        return artifact\n\n    # TODO: Generalize this for non-DigitalOcean users.\n    def to_s3_viewer_url(self) -&gt; hyperlink.URL:\n        \"\"\"Return a URL to view the Artifact files on a web-based S3 viewer.\n\n        Returns\n        -------\n            URL for viewing the Artifact.\n        \"\"\"\n        primary_s3 = self.s3[0]\n\n        query = {}\n        key = Path(primary_s3.key)\n        if len(key.parts) &gt; 1:\n            # View the parent directory in DigitalOcean.\n            query = {\"path\": f\"{key.parent}/\"}\n\n        return hyperlink.URL(\n            scheme=\"https\",\n            host=\"cloud.digitalocean.com\",\n            path=(\n                \"spaces\",\n                primary_s3.bucket,\n            ),\n            query=query,\n        )\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.AeromancyArtifact.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate our inputs.</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate our inputs.\"\"\"\n    # We don't know for sure that Weights and Biases holds artifact type\n    # strings subject to the same constraints as artifact name, but we'll\n    # enforce it here out of paranoia.\n    _validate_wandb_artifact_string(self.name, \"artifact\")\n    _validate_wandb_artifact_string(self.artifact_type, \"artifact type\")\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.AeromancyArtifact.as_wandb_artifact","title":"<code>as_wandb_artifact(metadata=None)</code>","text":"<p>Convert this into a Weights and Biases <code>Artifact</code>.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict | None</code> <p>Optional fields to associate with the <code>Artifact</code>. These will be stored and accessible on Weights and Biases.</p> <code>None</code> <code>optional</code> <code>dict | None</code> <p>Optional fields to associate with the <code>Artifact</code>. These will be stored and accessible on Weights and Biases.</p> <code>None</code> <p>Returns:</p> Type Description <code>    This object represented as a Weights and Biases `Artifact`.</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def as_wandb_artifact(\n    self,\n    metadata: dict | None = None,\n) -&gt; wandb.Artifact:\n    \"\"\"Convert this into a Weights and Biases `Artifact`.\n\n    Parameters\n    ----------\n    metadata, optional\n        Optional fields to associate with the `Artifact`. These will be\n        stored and accessible on Weights and Biases.\n\n    Returns\n    -------\n        This object represented as a Weights and Biases `Artifact`.\n    \"\"\"\n    primary_s3 = self.s3[0]\n    # Metadata here is intended as a debugging aid.\n    # We make a copy since we're going to modify it and the caller doesn't expect it\n    # to change.\n    metadata = dict(metadata or {})\n    metadata.update(\n        primary_s3_key=primary_s3.key,\n        primary_s3_bucket=primary_s3.bucket,\n        primary_s3_version=primary_s3.version_id,\n        # For viewing this Artifact on an S3 viewer webpage.\n        viewer_url=self.to_s3_viewer_url(),\n        num_files=len(self.s3),\n    )\n\n    description = f\"{primary_s3.bucket}/{primary_s3.key}\"\n    if len(self.s3) &gt; 1:\n        description = f\"{description} (+{len(self.s3) - 1} others)\"\n    artifact = wandb.Artifact(\n        name=self.name,\n        description=description,\n        type=self.artifact_type,\n        metadata=metadata,\n    )\n    # We need an external reference so W&amp;B knows when it changes.\n    for s3 in self.s3:\n        artifact.add_reference(name=s3.key, uri=str(s3.to_aeromancy_uri()))\n    return artifact\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.AeromancyArtifact.from_wandb_api_artifact","title":"<code>from_wandb_api_artifact(wandb_api_artifact)</code>  <code>classmethod</code>","text":"<p>Create an <code>AeromancyArtifact</code> from a Weights and Biases API artifact.</p> <p>Parameters:</p> Name Type Description Default <code>wandb_api_artifact</code> <code>Artifact</code> <p>Artifact to convert. Note that this is a Weights and Biases API Artifact, which is distinct from the typical Weights and Biases Artifact.</p> required <p>Returns:</p> Type Description <code>    An `AeromancyArtifact` corresponding to `wandb_api_artifact`</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>@classmethod\ndef from_wandb_api_artifact(cls, wandb_api_artifact: WandbApiArtifact):\n    \"\"\"Create an `AeromancyArtifact` from a Weights and Biases API artifact.\n\n    Parameters\n    ----------\n    wandb_api_artifact\n        Artifact to convert. Note that this is a Weights and Biases *API*\n        Artifact, which is distinct from the typical Weights and Biases\n        Artifact.\n\n    Returns\n    -------\n        An `AeromancyArtifact` corresponding to `wandb_api_artifact`\n    \"\"\"\n    s3_objects = []\n    for _, manifest_value in sorted(wandb_api_artifact.manifest.entries.items()):\n        if manifest_value.ref is None:\n            raise ValueError(\"No URI associated with manifest entry\")\n        aeromancy_uri = hyperlink.parse(manifest_value.ref)\n        s3 = VersionedS3Object.from_aeromancy_uri(aeromancy_uri)\n        s3_objects.append(s3)\n\n    artifact_type = wandb_api_artifact.type\n    artifact_name = WandbArtifactName.parse(wandb_api_artifact.name)\n\n    return AeromancyArtifact(\n        s3=s3_objects,\n        artifact_type=artifact_type,\n        name=artifact_name.artifact_name,\n    )\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.AeromancyArtifact.to_s3_viewer_url","title":"<code>to_s3_viewer_url()</code>","text":"<p>Return a URL to view the Artifact files on a web-based S3 viewer.</p> <p>Returns:</p> Type Description <code>    URL for viewing the Artifact.</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def to_s3_viewer_url(self) -&gt; hyperlink.URL:\n    \"\"\"Return a URL to view the Artifact files on a web-based S3 viewer.\n\n    Returns\n    -------\n        URL for viewing the Artifact.\n    \"\"\"\n    primary_s3 = self.s3[0]\n\n    query = {}\n    key = Path(primary_s3.key)\n    if len(key.parts) &gt; 1:\n        # View the parent directory in DigitalOcean.\n        query = {\"path\": f\"{key.parent}/\"}\n\n    return hyperlink.URL(\n        scheme=\"https\",\n        host=\"cloud.digitalocean.com\",\n        path=(\n            \"spaces\",\n            primary_s3.bucket,\n        ),\n        query=query,\n    )\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.Artifacts","title":"<code>Artifacts</code>","text":"<p>Bridge between Aeromancy and external artifact storage.</p> <p>This connects S3 objects to Weights and Bias artifacts and helps manages artifact dependencies.</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>class Artifacts:\n    \"\"\"Bridge between Aeromancy and external artifact storage.\n\n    This connects S3 objects to Weights and Bias artifacts and helps manages\n    artifact dependencies.\n    \"\"\"\n\n    def __init__(\n        self,\n        wandb_run: WandbRun,\n        s3_client: S3Client | None = None,\n    ):\n        \"\"\"Construct an `Artifacts` object for a specific Weights and Biases `Run`.\n\n        Parameters\n        ----------\n        wandb_run\n            Weights and Biases `Run` which will be associated with declared artifacts.\n        s3_client, optional\n            If missing, a default one will be set up from environment variables.\n        \"\"\"\n        if s3_client:\n            self._s3 = s3_client\n        else:\n            self._s3 = S3Client.from_env_variables()\n\n        self.wandb_run = wandb_run\n        self.wandb_api = wandb.Api()\n\n    def declare_output(\n        self,\n        name: str,\n        local_filenames: Sequence[Path],\n        s3_destination: S3Object,\n        artifact_type: str,\n        strip_prefix: Path | None = None,\n        metadata: dict | None = None,\n    ) -&gt; AeromancyArtifact:\n        \"\"\"Store a new artifact and log it as a produced artifact.\n\n        External artifacts are created from local files. Declaring them will\n        upload the files to S3 and register the artifact with Weights and\n        Biases.\n\n        Parameters\n        ----------\n        name\n            Artifact name. Must meet Weights and Biases naming conventions,\n            beyond that semantics are up to the caller/project design.\n        local_filenames\n            Paths to local files.\n        s3_destination\n            Where local files should be uploaded on S3.\n        artifact_type\n            Short description of the artifact type. Semantics are up to the\n            caller/project design.\n        strip_prefix, optional\n            Prefix of local_filenames to remove before uploading them to S3. For\n            example, if `strip_prefix=Path('/a/b')`, a local filename with\n            `Path('/a/b/c/d.txt')` will be uploaded to\n            `&lt;s3_destination&gt;/c/d.txt`\n        metadata, optional\n            Any additional information to associate with the artifact. Semantics\n            are up to the caller/project design, though types must be storable\n            by Weights and Biases.\n\n        Returns\n        -------\n            `AeromancyArtifact` representing the output.\n        \"\"\"\n        if not local_filenames:\n            raise ValueError(\"Need at least 1 item in local_filenames to be an output.\")\n\n        s3_objects = []\n        for local_filename in local_filenames:\n            new_path = local_filename\n            if strip_prefix:\n                # Need a trailing slash since otherwise we end up with an absolute path.\n                new_path = str(new_path).removeprefix(str(strip_prefix) + \"/\")\n            s3_objects.append(self._s3.put(local_filename, s3_destination / new_path))\n        # Upgrade it to an AeromancyArtifact.\n        aero_artifact = AeromancyArtifact(\n            name=name,\n            artifact_type=artifact_type,\n            s3=s3_objects,\n        )\n\n        wandb_artifact = aero_artifact.as_wandb_artifact(metadata=metadata)\n        self.wandb_run.log_artifact(wandb_artifact)\n\n        return aero_artifact\n\n    def _try_use_artifact(self, wandb_artifact, use_as):\n        try:\n            self.wandb_run.use_artifact(wandb_artifact, use_as=use_as)\n        except wandb.errors.CommError as comm_error:\n            raise ValueError(\n                f\"Error using artifact: {wandb_artifact!r}\",\n            ) from comm_error\n\n    def declare_input(\n        self,\n        artifact: ArtifactDescriptor,\n        use_as: str | None = None,\n    ) -&gt; Sequence[Path]:\n        \"\"\"Record a dependency on an existing artifact and provide local access.\n\n        This indicates that our current Weights and Biases `Run` depends on the files in\n        the `artifact` and will resolve and fetch the files in the `artifact`.\n\n        Parameters\n        ----------\n        artifact\n            An artifact that our associated Weights and Biases `Run` depends on.\n        use_as, optional\n            Description of how we're using the artifact (e.g., \"train\", \"test\").\n            Most useful when there are multiple input artifacts of the same\n            type.\n\n        Returns\n        -------\n            Returns a local filesystem version of the artifact.\n        \"\"\"\n        if isinstance(artifact, str):\n            self._try_use_artifact(artifact, use_as=use_as)\n\n            api_artifact = self.wandb_api.artifact(artifact)\n            if api_artifact.qualified_name != api_artifact.source_qualified_name:\n                logger.info(f\"Resolved {api_artifact.name!r} -&gt; {api_artifact.version}\")\n            artifact = AeromancyArtifact.from_wandb_api_artifact(api_artifact)\n        else:\n            wandb_artifact = artifact.as_wandb_artifact()\n            self._try_use_artifact(wandb_artifact, use_as=use_as)\n\n        local_paths = [self._s3.fetch(s3) for s3 in artifact.s3]\n        return local_paths\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.Artifacts.__init__","title":"<code>__init__(wandb_run, s3_client=None)</code>","text":"<p>Construct an <code>Artifacts</code> object for a specific Weights and Biases <code>Run</code>.</p> <p>Parameters:</p> Name Type Description Default <code>wandb_run</code> <code>Run</code> <p>Weights and Biases <code>Run</code> which will be associated with declared artifacts.</p> required <code>s3_client</code> <code>S3Client | None</code> <p>If missing, a default one will be set up from environment variables.</p> <code>None</code> <code>optional</code> <code>S3Client | None</code> <p>If missing, a default one will be set up from environment variables.</p> <code>None</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def __init__(\n    self,\n    wandb_run: WandbRun,\n    s3_client: S3Client | None = None,\n):\n    \"\"\"Construct an `Artifacts` object for a specific Weights and Biases `Run`.\n\n    Parameters\n    ----------\n    wandb_run\n        Weights and Biases `Run` which will be associated with declared artifacts.\n    s3_client, optional\n        If missing, a default one will be set up from environment variables.\n    \"\"\"\n    if s3_client:\n        self._s3 = s3_client\n    else:\n        self._s3 = S3Client.from_env_variables()\n\n    self.wandb_run = wandb_run\n    self.wandb_api = wandb.Api()\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.Artifacts.declare_input","title":"<code>declare_input(artifact, use_as=None)</code>","text":"<p>Record a dependency on an existing artifact and provide local access.</p> <p>This indicates that our current Weights and Biases <code>Run</code> depends on the files in the <code>artifact</code> and will resolve and fetch the files in the <code>artifact</code>.</p> <p>Parameters:</p> Name Type Description Default <code>artifact</code> <code>ArtifactDescriptor</code> <p>An artifact that our associated Weights and Biases <code>Run</code> depends on.</p> required <code>use_as</code> <code>str | None</code> <p>Description of how we're using the artifact (e.g., \"train\", \"test\"). Most useful when there are multiple input artifacts of the same type.</p> <code>None</code> <code>optional</code> <code>str | None</code> <p>Description of how we're using the artifact (e.g., \"train\", \"test\"). Most useful when there are multiple input artifacts of the same type.</p> <code>None</code> <p>Returns:</p> Type Description <code>    Returns a local filesystem version of the artifact.</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def declare_input(\n    self,\n    artifact: ArtifactDescriptor,\n    use_as: str | None = None,\n) -&gt; Sequence[Path]:\n    \"\"\"Record a dependency on an existing artifact and provide local access.\n\n    This indicates that our current Weights and Biases `Run` depends on the files in\n    the `artifact` and will resolve and fetch the files in the `artifact`.\n\n    Parameters\n    ----------\n    artifact\n        An artifact that our associated Weights and Biases `Run` depends on.\n    use_as, optional\n        Description of how we're using the artifact (e.g., \"train\", \"test\").\n        Most useful when there are multiple input artifacts of the same\n        type.\n\n    Returns\n    -------\n        Returns a local filesystem version of the artifact.\n    \"\"\"\n    if isinstance(artifact, str):\n        self._try_use_artifact(artifact, use_as=use_as)\n\n        api_artifact = self.wandb_api.artifact(artifact)\n        if api_artifact.qualified_name != api_artifact.source_qualified_name:\n            logger.info(f\"Resolved {api_artifact.name!r} -&gt; {api_artifact.version}\")\n        artifact = AeromancyArtifact.from_wandb_api_artifact(api_artifact)\n    else:\n        wandb_artifact = artifact.as_wandb_artifact()\n        self._try_use_artifact(wandb_artifact, use_as=use_as)\n\n    local_paths = [self._s3.fetch(s3) for s3 in artifact.s3]\n    return local_paths\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.Artifacts.declare_output","title":"<code>declare_output(name, local_filenames, s3_destination, artifact_type, strip_prefix=None, metadata=None)</code>","text":"<p>Store a new artifact and log it as a produced artifact.</p> <p>External artifacts are created from local files. Declaring them will upload the files to S3 and register the artifact with Weights and Biases.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Artifact name. Must meet Weights and Biases naming conventions, beyond that semantics are up to the caller/project design.</p> required <code>local_filenames</code> <code>Sequence[Path]</code> <p>Paths to local files.</p> required <code>s3_destination</code> <code>S3Object</code> <p>Where local files should be uploaded on S3.</p> required <code>artifact_type</code> <code>str</code> <p>Short description of the artifact type. Semantics are up to the caller/project design.</p> required <code>strip_prefix</code> <code>Path | None</code> <p>Prefix of local_filenames to remove before uploading them to S3. For example, if <code>strip_prefix=Path('/a/b')</code>, a local filename with <code>Path('/a/b/c/d.txt')</code> will be uploaded to <code>&lt;s3_destination&gt;/c/d.txt</code></p> <code>None</code> <code>optional</code> <code>Path | None</code> <p>Prefix of local_filenames to remove before uploading them to S3. For example, if <code>strip_prefix=Path('/a/b')</code>, a local filename with <code>Path('/a/b/c/d.txt')</code> will be uploaded to <code>&lt;s3_destination&gt;/c/d.txt</code></p> <code>None</code> <code>metadata</code> <code>dict | None</code> <p>Any additional information to associate with the artifact. Semantics are up to the caller/project design, though types must be storable by Weights and Biases.</p> <code>None</code> <code>optional</code> <code>dict | None</code> <p>Any additional information to associate with the artifact. Semantics are up to the caller/project design, though types must be storable by Weights and Biases.</p> <code>None</code> <p>Returns:</p> Type Description <code>    `AeromancyArtifact` representing the output.</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def declare_output(\n    self,\n    name: str,\n    local_filenames: Sequence[Path],\n    s3_destination: S3Object,\n    artifact_type: str,\n    strip_prefix: Path | None = None,\n    metadata: dict | None = None,\n) -&gt; AeromancyArtifact:\n    \"\"\"Store a new artifact and log it as a produced artifact.\n\n    External artifacts are created from local files. Declaring them will\n    upload the files to S3 and register the artifact with Weights and\n    Biases.\n\n    Parameters\n    ----------\n    name\n        Artifact name. Must meet Weights and Biases naming conventions,\n        beyond that semantics are up to the caller/project design.\n    local_filenames\n        Paths to local files.\n    s3_destination\n        Where local files should be uploaded on S3.\n    artifact_type\n        Short description of the artifact type. Semantics are up to the\n        caller/project design.\n    strip_prefix, optional\n        Prefix of local_filenames to remove before uploading them to S3. For\n        example, if `strip_prefix=Path('/a/b')`, a local filename with\n        `Path('/a/b/c/d.txt')` will be uploaded to\n        `&lt;s3_destination&gt;/c/d.txt`\n    metadata, optional\n        Any additional information to associate with the artifact. Semantics\n        are up to the caller/project design, though types must be storable\n        by Weights and Biases.\n\n    Returns\n    -------\n        `AeromancyArtifact` representing the output.\n    \"\"\"\n    if not local_filenames:\n        raise ValueError(\"Need at least 1 item in local_filenames to be an output.\")\n\n    s3_objects = []\n    for local_filename in local_filenames:\n        new_path = local_filename\n        if strip_prefix:\n            # Need a trailing slash since otherwise we end up with an absolute path.\n            new_path = str(new_path).removeprefix(str(strip_prefix) + \"/\")\n        s3_objects.append(self._s3.put(local_filename, s3_destination / new_path))\n    # Upgrade it to an AeromancyArtifact.\n    aero_artifact = AeromancyArtifact(\n        name=name,\n        artifact_type=artifact_type,\n        s3=s3_objects,\n    )\n\n    wandb_artifact = aero_artifact.as_wandb_artifact(metadata=metadata)\n    self.wandb_run.log_artifact(wandb_artifact)\n\n    return aero_artifact\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.WandbArtifactName","title":"<code>WandbArtifactName</code>","text":"<p>             Bases: <code>Struct</code></p> <p>Represents a parse of a Weights and Biases artifact name.</p> <p>Can include None for any missing entries.</p> <p>Attributes:</p> Name Type Description <code>entity</code> <code>str | None</code> <p>Entity name (person or organization on Weights and Biases).</p> <code>project</code> <code>str | None</code> <p>Name of Weights and Biases project.</p> <code>artifact_name</code> <code>str</code> <p>Should comply with Weights and Biases artifact naming scheme (see <code>validate_wandb_artifact_string</code>).</p> <code>version</code> <code>str | None</code> <p>Weights and Biases version string (e.g., \"latest\", \"v0\").</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>class WandbArtifactName(msgspec.Struct):\n    \"\"\"Represents a parse of a Weights and Biases artifact name.\n\n    Can include None for any missing entries.\n\n    Attributes\n    ----------\n    entity\n        Entity name (person or organization on Weights and Biases).\n    project\n        Name of Weights and Biases project.\n    artifact_name\n        Should comply with Weights and Biases artifact naming scheme\n        (see `validate_wandb_artifact_string`).\n    version\n        Weights and Biases version string (e.g., \"latest\", \"v0\").\n    \"\"\"\n\n    entity: str | None\n    project: str | None\n    artifact_name: str\n    version: str | None\n\n    def __post_init__(self):\n        \"\"\"Validate our inputs.\"\"\"\n        # We don't know for sure that Weights and Biases holds entity, project,\n        # and version strings subject to the same constraints as artifact name,\n        # but we'll enforce it here out of paranoia.\n        _validate_wandb_artifact_string(self.entity, \"entity\")\n        _validate_wandb_artifact_string(self.project, \"project\")\n        _validate_wandb_artifact_string(self.artifact_name, \"artifact\")\n        _validate_wandb_artifact_string(self.version, \"version\")\n\n    def __str__(self) -&gt; str:\n        \"\"\"Format as a Weights and Biases artifact string.\"\"\"\n        pieces = []\n        if self.entity:\n            pieces.append(self.entity)\n        if self.project:\n            pieces.append(self.project)\n        pieces.append(self.artifact_name)\n        base = \"/\".join(pieces)\n        if self.version:\n            return f\"{base}:{self.version}\"\n        else:\n            return base\n\n    @classmethod\n    def parse(\n        cls,\n        wandb_artifact_name: str,\n    ) -&gt; \"WandbArtifactName\":\n        \"\"\"Parse a string representing a Weights and Biases artifact.\n\n        Supports parsing the following formats:\n\n        - `name`\n        - `project/name`\n        - `org/project/name`\n        - `org/project/name:v0`\n        - `org/project/name:latest`\n\n        Any missing fields will be given the value None.\n\n        Parameters\n        ----------\n        wandb_artifact_name\n            String to parse.\n\n        Returns\n        -------\n            Instance of `WandbArtifactName` with values from `wandb_artifact_name`\n        \"\"\"\n        project = None\n        entity = None\n        version = None\n\n        pieces = wandb_artifact_name.split(\"/\")\n        # If there's a version, pull it off the last piece.\n        if \":\" in pieces[-1]:\n            last_part, version = pieces[-1].rsplit(\":\", 1)\n            pieces[-1] = last_part\n\n        match len(pieces):\n            case 1:\n                artifact_name = pieces[0]\n            case 2:\n                project, artifact_name = pieces\n            case 3:\n                entity, project, artifact_name = pieces\n            case _:\n                raise ValueError(\n                    f\"Not sure how to parse: {wandb_artifact_name!r}\",\n                )\n\n        return cls(entity, project, artifact_name, version)\n\n    def matches(self, other_artifact_name: \"WandbArtifactName\") -&gt; bool:\n        \"\"\"Test whether this and another artifact name are compatible.\n\n        Artifact names match when all set fields match, ignoring versions.\n        This is different than equality, since it allows for fields to be\n        unset on one or both of the artifact names.\n\n        Parameters\n        ----------\n        other_artifact_name\n            The artifact name to match against.\n\n        Returns\n        -------\n            True if they match.\n        \"\"\"\n        if (\n            self.entity\n            and other_artifact_name.entity\n            and self.entity != other_artifact_name.entity\n        ):\n            return False\n\n        if (\n            self.project\n            and other_artifact_name.project\n            and self.project != other_artifact_name.project\n        ):\n            return False\n\n        if self.artifact_name != other_artifact_name.artifact_name:\n            return False\n\n        return True\n\n    def incorporate_overrides(self):\n        \"\"\"Incorporate artifact version overrides.\n\n        If these are set for this artifact via environment variables and we\n        don't already have a specific version set for this artifact, we'll use\n        the overridden version.\n        \"\"\"\n        for artifact_name in get_runtime_environment().artifact_overrides:\n            parsed_artifact_name = self.__class__.parse(artifact_name)\n            if self.matches(parsed_artifact_name):\n                self.version = parsed_artifact_name.version\n                break\n\n    @classmethod\n    def resolve_artifact_name(\n        cls,\n        artifact_name: str,\n        default_project_name: str | None = None,\n    ) -&gt; str:\n        \"\"\"Resolve an artifact name, incorporating overrides.\n\n        This will always pick the latest version of an artifact unless it has\n        been specifically overridden by `--artifact-override`.\n\n        Note that this method works without net access and thus won't actually\n        resolve the \"latest\" tag to a specific version.\n\n        Parameters\n        ----------\n        artifact_name\n            Artifact name to resolve. Version will default to \"latest\", entity\n            to Weights and Biases default, and project name to the `Tracker`'s\n            project name.\n        default_project_name\n            Project name will be filled in from the `artifact_name` if it\n            includes one (e.g., \"project/artifact:v3\"). If not, we will use this\n            value. Note that if this value is None, we can still incorporate\n            overrides (but project name won't be used to determine whether\n            entities match, so it could be less precise).\n\n        Returns\n        -------\n            Resolved artifact name as a string.\n        \"\"\"\n        wandb_artifact_name = cls.parse(artifact_name)\n        # Fill in some defaults.\n        wandb_artifact_name.project = (\n            wandb_artifact_name.project or default_project_name\n        )\n        wandb_artifact_name.version = wandb_artifact_name.version or \"latest\"\n        wandb_artifact_name.incorporate_overrides()\n\n        return str(wandb_artifact_name)\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.WandbArtifactName.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate our inputs.</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate our inputs.\"\"\"\n    # We don't know for sure that Weights and Biases holds entity, project,\n    # and version strings subject to the same constraints as artifact name,\n    # but we'll enforce it here out of paranoia.\n    _validate_wandb_artifact_string(self.entity, \"entity\")\n    _validate_wandb_artifact_string(self.project, \"project\")\n    _validate_wandb_artifact_string(self.artifact_name, \"artifact\")\n    _validate_wandb_artifact_string(self.version, \"version\")\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.WandbArtifactName.__str__","title":"<code>__str__()</code>","text":"<p>Format as a Weights and Biases artifact string.</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Format as a Weights and Biases artifact string.\"\"\"\n    pieces = []\n    if self.entity:\n        pieces.append(self.entity)\n    if self.project:\n        pieces.append(self.project)\n    pieces.append(self.artifact_name)\n    base = \"/\".join(pieces)\n    if self.version:\n        return f\"{base}:{self.version}\"\n    else:\n        return base\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.WandbArtifactName.incorporate_overrides","title":"<code>incorporate_overrides()</code>","text":"<p>Incorporate artifact version overrides.</p> <p>If these are set for this artifact via environment variables and we don't already have a specific version set for this artifact, we'll use the overridden version.</p> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def incorporate_overrides(self):\n    \"\"\"Incorporate artifact version overrides.\n\n    If these are set for this artifact via environment variables and we\n    don't already have a specific version set for this artifact, we'll use\n    the overridden version.\n    \"\"\"\n    for artifact_name in get_runtime_environment().artifact_overrides:\n        parsed_artifact_name = self.__class__.parse(artifact_name)\n        if self.matches(parsed_artifact_name):\n            self.version = parsed_artifact_name.version\n            break\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.WandbArtifactName.matches","title":"<code>matches(other_artifact_name)</code>","text":"<p>Test whether this and another artifact name are compatible.</p> <p>Artifact names match when all set fields match, ignoring versions. This is different than equality, since it allows for fields to be unset on one or both of the artifact names.</p> <p>Parameters:</p> Name Type Description Default <code>other_artifact_name</code> <code>WandbArtifactName</code> <p>The artifact name to match against.</p> required <p>Returns:</p> Type Description <code>    True if they match.</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>def matches(self, other_artifact_name: \"WandbArtifactName\") -&gt; bool:\n    \"\"\"Test whether this and another artifact name are compatible.\n\n    Artifact names match when all set fields match, ignoring versions.\n    This is different than equality, since it allows for fields to be\n    unset on one or both of the artifact names.\n\n    Parameters\n    ----------\n    other_artifact_name\n        The artifact name to match against.\n\n    Returns\n    -------\n        True if they match.\n    \"\"\"\n    if (\n        self.entity\n        and other_artifact_name.entity\n        and self.entity != other_artifact_name.entity\n    ):\n        return False\n\n    if (\n        self.project\n        and other_artifact_name.project\n        and self.project != other_artifact_name.project\n    ):\n        return False\n\n    if self.artifact_name != other_artifact_name.artifact_name:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.WandbArtifactName.parse","title":"<code>parse(wandb_artifact_name)</code>  <code>classmethod</code>","text":"<p>Parse a string representing a Weights and Biases artifact.</p> <p>Supports parsing the following formats:</p> <ul> <li><code>name</code></li> <li><code>project/name</code></li> <li><code>org/project/name</code></li> <li><code>org/project/name:v0</code></li> <li><code>org/project/name:latest</code></li> </ul> <p>Any missing fields will be given the value None.</p> <p>Parameters:</p> Name Type Description Default <code>wandb_artifact_name</code> <code>str</code> <p>String to parse.</p> required <p>Returns:</p> Type Description <code>    Instance of `WandbArtifactName` with values from `wandb_artifact_name`</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>@classmethod\ndef parse(\n    cls,\n    wandb_artifact_name: str,\n) -&gt; \"WandbArtifactName\":\n    \"\"\"Parse a string representing a Weights and Biases artifact.\n\n    Supports parsing the following formats:\n\n    - `name`\n    - `project/name`\n    - `org/project/name`\n    - `org/project/name:v0`\n    - `org/project/name:latest`\n\n    Any missing fields will be given the value None.\n\n    Parameters\n    ----------\n    wandb_artifact_name\n        String to parse.\n\n    Returns\n    -------\n        Instance of `WandbArtifactName` with values from `wandb_artifact_name`\n    \"\"\"\n    project = None\n    entity = None\n    version = None\n\n    pieces = wandb_artifact_name.split(\"/\")\n    # If there's a version, pull it off the last piece.\n    if \":\" in pieces[-1]:\n        last_part, version = pieces[-1].rsplit(\":\", 1)\n        pieces[-1] = last_part\n\n    match len(pieces):\n        case 1:\n            artifact_name = pieces[0]\n        case 2:\n            project, artifact_name = pieces\n        case 3:\n            entity, project, artifact_name = pieces\n        case _:\n            raise ValueError(\n                f\"Not sure how to parse: {wandb_artifact_name!r}\",\n            )\n\n    return cls(entity, project, artifact_name, version)\n</code></pre>"},{"location":"reference/aeromancy/artifacts/#aeromancy.artifacts.WandbArtifactName.resolve_artifact_name","title":"<code>resolve_artifact_name(artifact_name, default_project_name=None)</code>  <code>classmethod</code>","text":"<p>Resolve an artifact name, incorporating overrides.</p> <p>This will always pick the latest version of an artifact unless it has been specifically overridden by <code>--artifact-override</code>.</p> <p>Note that this method works without net access and thus won't actually resolve the \"latest\" tag to a specific version.</p> <p>Parameters:</p> Name Type Description Default <code>artifact_name</code> <code>str</code> <p>Artifact name to resolve. Version will default to \"latest\", entity to Weights and Biases default, and project name to the <code>Tracker</code>'s project name.</p> required <code>default_project_name</code> <code>str | None</code> <p>Project name will be filled in from the <code>artifact_name</code> if it includes one (e.g., \"project/artifact:v3\"). If not, we will use this value. Note that if this value is None, we can still incorporate overrides (but project name won't be used to determine whether entities match, so it could be less precise).</p> <code>None</code> <p>Returns:</p> Type Description <code>    Resolved artifact name as a string.</code> Source code in <code>aeromancy/artifacts.py</code> <pre><code>@classmethod\ndef resolve_artifact_name(\n    cls,\n    artifact_name: str,\n    default_project_name: str | None = None,\n) -&gt; str:\n    \"\"\"Resolve an artifact name, incorporating overrides.\n\n    This will always pick the latest version of an artifact unless it has\n    been specifically overridden by `--artifact-override`.\n\n    Note that this method works without net access and thus won't actually\n    resolve the \"latest\" tag to a specific version.\n\n    Parameters\n    ----------\n    artifact_name\n        Artifact name to resolve. Version will default to \"latest\", entity\n        to Weights and Biases default, and project name to the `Tracker`'s\n        project name.\n    default_project_name\n        Project name will be filled in from the `artifact_name` if it\n        includes one (e.g., \"project/artifact:v3\"). If not, we will use this\n        value. Note that if this value is None, we can still incorporate\n        overrides (but project name won't be used to determine whether\n        entities match, so it could be less precise).\n\n    Returns\n    -------\n        Resolved artifact name as a string.\n    \"\"\"\n    wandb_artifact_name = cls.parse(artifact_name)\n    # Fill in some defaults.\n    wandb_artifact_name.project = (\n        wandb_artifact_name.project or default_project_name\n    )\n    wandb_artifact_name.version = wandb_artifact_name.version or \"latest\"\n    wandb_artifact_name.incorporate_overrides()\n\n    return str(wandb_artifact_name)\n</code></pre>"},{"location":"reference/aeromancy/click_options/","title":"click_options","text":"<p>Groups of Click options for the main Aeromancy CLI interface.</p>"},{"location":"reference/aeromancy/click_options/#aeromancy.click_options.aeromancy_click_options","title":"<code>aeromancy_click_options(function)</code>","text":"<p>Wrap <code>function</code> with all Click options for Aeromancy.</p> <p>This is intended to wrap an <code>aeromain</code> function.</p> Source code in <code>aeromancy/click_options.py</code> <pre><code>def aeromancy_click_options(function):\n    \"\"\"Wrap `function` with all Click options for Aeromancy.\n\n    This is intended to wrap an `aeromain` function.\n    \"\"\"\n    # NOTE: Keep in sync with OPTION_GROUPS.\n\n    @click.option(\n        \"-o\",\n        \"--only\",\n        default=None,\n        type=str,\n        metavar=\"SUBSTRS\",\n        help=\"If set: comma-separated list of substrings. We'll only run jobs which \"\n        \"match at least one of these (in dependency order).\",\n    )\n    @click.option(\n        \"--graph\",\n        is_flag=True,\n        help=\"If set: show a graph of job dependencies and exit.\",\n    )\n    @click.option(\n        \"--list-actions\",\n        \"--list\",\n        is_flag=True,\n        help=\"If set: show a list of all job names and exit.\",\n    )\n    @runner_click_options\n    @functools.wraps(function)\n    def wrapper_aeromancy_options(*args, **kwargs):\n        return function(*args, **kwargs)\n\n    return wrapper_aeromancy_options\n</code></pre>"},{"location":"reference/aeromancy/click_options/#aeromancy.click_options.runner_click_options","title":"<code>runner_click_options(function)</code>","text":"<p>Wrap <code>function</code> with all Click options for Aeromancy runtime.</p> Source code in <code>aeromancy/click_options.py</code> <pre><code>def runner_click_options(function):\n    \"\"\"Wrap `function` with all Click options for Aeromancy runtime.\"\"\"\n    # NOTE: Keep in sync with OPTION_GROUPS.\n\n    @click.option(\n        \"--dev\",\n        is_flag=True,\n        help=\"If set, use development mode for quickly testing changes (don't actually \"\n        \"track anything, or use Weights and Biases, S3, Docker, etc.).\",\n    )\n    @click.option(\n        \"--debug\",\n        is_flag=True,\n        help=\"Used to aid in Aeromancy debugging. If set, Aeromancy and related tools \"\n        \"(e.g., Docker) will be more verbose.\",\n    )\n    @click.option(\n        \"--debug-shell\",\n        help=\"If True, open a debug shell in the Docker container instead of running \"\n        \"Aeromain. Implies --debug.\",\n        is_flag=True,\n    )\n    @click.option(\n        \"--extra-docker-run-args\",\n        default=\"\",\n        metavar=\"ARGS\",\n        help=(\n            \"Flags or arguments to pass to Docker run verbatim (e.g., extra volumes to \"\n            \"mount). You should generally not need to change this, but it may be \"\n            \"set in pdm scripts when setting up a project.\"\n        ),\n    )\n    @click.option(\n        \"--extra-debian-package\",\n        \"extra_debian_packages\",\n        metavar=\"PKGS\",\n        multiple=True,\n        help=(\n            \"Names of Debian packages to include in the Docker image in addition to \"\n            \"standard packages required by Aeromancy. Specify this option once per \"\n            \"extra package. You should generally not need to change this, but it may \"\n            \"be set in pdm scripts when setting up a project.\"\n        ),\n    )\n    @click.option(\n        \"--extra-env-var\",\n        \"extra_env_vars\",\n        metavar=\"VARS\",\n        multiple=True,\n        help=(\n            \"Extra environment variables to passthrough to Aeromancy. Specify this \"\n            \"option once per variable. You should generally not need to change this, \"\n            \"but it may be set in pdm scripts when setting up a project.\"\n        ),\n    )\n    @click.option(\n        \"--artifact-override\",\n        \"artifact_overrides\",\n        metavar=\"NAMEVER\",\n        help=(\n            \"Set this to a versioned Weights and Biases artifact (e.g, 'a/b/c:v3') to \"\n            \"force using that version for input. May be specified multiple times. For \"\n            \"any artifact not mentioned, we will default to its latest Weights and \"\n            \"Biases version.\"\n        ),\n        multiple=True,\n    )\n    @click.option(\n        \"--aeromain\",\n        \"aeromain_path\",\n        default=\"src/main.py\",\n        metavar=\"PATH\",\n        # To minimize confusion since this is only intended for\n        # debugging/testing Aeromancy itself.\n        hidden=True,\n        help=\"Set an alternate Aeromain file to run.\",\n    )\n    @functools.wraps(function)\n    def wrapper_aeromancy_options(*args, **kwargs):\n        return function(*args, **kwargs)\n\n    return wrapper_aeromancy_options\n</code></pre>"},{"location":"reference/aeromancy/export_utils/","title":"export_utils","text":"<p>Utilities for working with Aeromancy artifacts outside of Aeromancy.</p> <p>While Aeromancy works best when you're keeping artifacts within Aeromancy, sometimes you just need to pull an artifact out and analyze it in a Notebook.</p> <p>Warning: Here be dragons (cough hacks). Code in this module relies on Aeromancy internals and is subject to change.</p>"},{"location":"reference/aeromancy/export_utils/#aeromancy.export_utils.get_artifact_paths","title":"<code>get_artifact_paths(artifact_name, dev=False)</code>","text":"<p>Get local paths for an Aeromancy Artifact for exporting purposes.</p> <p>This will not track a dependency on the artifact and must be run outside of an Aeromancy runner script (Aeromain). To get artifact paths within Aeromancy, just use <code>Tracker.declare_input()</code> which will track dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>artifact_name</code> <code>str</code> <p>An mostly-qualified artifact name, minimally with project and artifact names (e.g., \"project/artifact-name\"). Version numbers (\"project/artifact-name:v2\") and organization entities (\"mycorp/project/artifact-name\") can also be included.</p> required <code>dev</code> <code>bool</code> <p>If True, use the dev version (FakeTracker, FakeCache, etc.) of the artifact. Otherwise, use the Weights and Biases version (requires network access).</p> <code>False</code> <p>Returns:</p> Type Description <code>    A list of local paths for where to find the artifact.</code> Source code in <code>aeromancy/export_utils.py</code> <pre><code>def get_artifact_paths(\n    artifact_name: str,\n    dev: bool = False,\n) -&gt; Sequence[Path]:\n    \"\"\"Get local paths for an Aeromancy Artifact for exporting purposes.\n\n    This will not track a dependency on the artifact and must be run outside of\n    an Aeromancy runner script (Aeromain). To get artifact paths within\n    Aeromancy, just use `Tracker.declare_input()` which will track dependencies.\n\n    Parameters\n    ----------\n    artifact_name\n        An mostly-qualified artifact name, minimally with project and artifact\n        names (e.g., \"project/artifact-name\"). Version numbers\n        (\"project/artifact-name:v2\") and organization entities\n        (\"mycorp/project/artifact-name\") can also be included.\n    dev\n        If True, use the dev version (FakeTracker, FakeCache, etc.) of the\n        artifact. Otherwise, use the Weights and Biases version (requires\n        network access).\n\n    Returns\n    -------\n        A list of local paths for where to find the artifact.\n    \"\"\"\n    # First, make sure we're not running via an Aeromancy runner script, since\n    # this method is not intended to be used there.\n    if AEROMANCY_DEV_MODE_ENV in os.environ:\n        raise RuntimeError(\n            \"get_artifact_paths() should only be used in Notebooks or non-Aeromancy \"\n            \"scripts. Within Aeromancy, getting an artifact path should be done \"\n            \"through Tracker.declare_input().\",\n        )\n    # Since we're not running in an Aeromancy runner script, perform any\n    # necessary environment tweaks.\n    _ensure_valid_environment()\n\n    original_artifact_name = artifact_name\n    artifact_name = WandbArtifactName.resolve_artifact_name(\n        artifact_name=original_artifact_name,\n        default_project_name=None,\n    )\n\n    if dev:\n        # Project must be specified as part of `artifact_name` or we won't match\n        # it. To keep the API simple, we don't include default_project_name as a\n        # parameter.\n        tracker = FakeTracker(project_name=\"fake_project\")\n        try:\n            paths = tracker.declare_input(artifact_name)\n        except KeyError as ke:\n            raise KeyError(\n                f\"Couldn't find artifact {original_artifact_name!r} \"\n                f\"(resolved to {artifact_name!r})\",\n            ) from ke\n    else:\n        artifact_handler = Artifacts(wandb_run=_MockWandbRun())\n        paths = artifact_handler.declare_input(artifact_name)\n\n    return paths\n</code></pre>"},{"location":"reference/aeromancy/fake_tracker/","title":"fake_tracker","text":"<p>Fake Tracker for fast development.</p> <p>This should close enough to the Weights and Biases Tracker to run <code>Action</code>s, etc. but doesn't actually track anything. It is the default Tracker for <code>--dev</code> mode and intended for testing features in a faster edit-run-debug loop than Aeromancy normally supports.</p> <p>Limitations:     - Only supports a single version of each artifact, so these get clobbered by       default.     - Since it's not connected with Weights and Biases, it only knows about artifacts       that were produced in <code>--dev</code> mode (or manually transferred to its cache).</p>"},{"location":"reference/aeromancy/fake_tracker/#aeromancy.fake_tracker.FakeArtifactMapping","title":"<code>FakeArtifactMapping</code>","text":"<p>             Bases: <code>Struct</code></p> <p>Structure to record and persist AeromancyArtifact names.</p> <p>Attributes:</p> Name Type Description <code>artifacts_by_name</code> <code>dict[str, AeromancyArtifact]</code> <p>Mappping from artifact name to actual artifact.</p> Source code in <code>aeromancy/fake_tracker.py</code> <pre><code>class FakeArtifactMapping(msgspec.Struct):\n    \"\"\"Structure to record and persist AeromancyArtifact names.\n\n    Attributes\n    ----------\n    artifacts_by_name\n        Mappping from artifact name to actual artifact.\n    \"\"\"\n\n    artifacts_by_name: dict[str, AeromancyArtifact]\n</code></pre>"},{"location":"reference/aeromancy/fake_tracker/#aeromancy.fake_tracker.FakeTracker","title":"<code>FakeTracker</code>","text":"<p>             Bases: <code>Tracker</code></p> <p>Fake Tracker for fast development.</p> <p>This includes a local cache for artifacts, but doesn't actually use S3 or Weights and Biases for storage. Artifact names follow W&amp;B conventions so that real artifacts can be transferred over for more realistic development.</p> Source code in <code>aeromancy/fake_tracker.py</code> <pre><code>class FakeTracker(Tracker):\n    \"\"\"Fake Tracker for fast development.\n\n    This includes a local cache for artifacts, but doesn't actually use S3 or\n    Weights and Biases for storage. Artifact names follow W&amp;B conventions so\n    that real artifacts can be transferred over for more realistic development.\n    \"\"\"\n\n    @override\n    def __init__(\n        self,\n        project_name: str,\n        config: dict | None = None,\n        job_type: str | None = None,\n        job_group: str | None = None,\n    ):\n        Tracker.__init__(\n            self,\n            project_name=project_name,\n            config=config,\n            job_type=job_type,\n            job_group=job_group,\n        )\n\n        self.cache_root_path = Path(\"~/FakeCache\").expanduser().resolve()\n        self.cache = Cache(cache_root=self.cache_root_path)\n        self.mapping_path = self.cache_root_path / \"artifact_mapping.json\"\n        self._read_artifact_mapping()\n\n    def _read_artifact_mapping(self):\n        if self.mapping_path.exists():\n            with self.mapping_path.open() as mapping_file:\n                mapping_json = mapping_file.read()\n            mapping = msgspec.json.decode(mapping_json, type=FakeArtifactMapping)\n        else:\n            mapping = FakeArtifactMapping({})\n\n        self.artifact_mapping = mapping\n\n    def _set_artifact_mapping(self, name, artifact):\n        self.artifact_mapping.artifacts_by_name[str(name)] = artifact\n\n        # Save to disk.\n        jsonified = msgspec.json.encode(self.artifact_mapping)\n        self.cache_root_path.mkdir(parents=True, exist_ok=True)\n        with self.mapping_path.open(\"wb\") as checksums:\n            checksums.write(jsonified)\n\n    @override\n    def __enter__(self):\n        params = dict(self.__dict__)\n        params.pop(\"cache\")\n        params.pop(\"artifact_mapping\")\n        console.log(\"Started FakeTracker:\", params)\n        self._start_time = datetime.datetime.now(tz=datetime.timezone.utc)\n\n        return self\n\n    @override\n    def __exit__(self, exctype, excinst, exctb) -&gt; bool:\n        duration = datetime.datetime.now(tz=datetime.timezone.utc) - self._start_time\n        console.log(\n            f\"FakeTracker exited after {humanize.precisedelta(duration)}\",\n        )\n\n        if exctype is not None:\n            if exctype is _BailoutError:\n                # Exit immediately without all the logging.\n                console.log(\"Bailout requested, exiting.\")\n                raise SystemExit\n\n            if get_runtime_environment().debug_mode:\n                logger.exception(\"Exception!\")\n                console.print_exception(show_locals=True, suppress=[])\n            else:\n                logger.exception(\n                    \"Exception! (see more details with --debug)\",\n                )\n\n        return False\n\n    @override\n    def declare_output(\n        self,\n        name: str,\n        local_filenames: Sequence[Path],\n        s3_destination: S3Object,\n        artifact_type: str,\n        strip_prefix: Path | None = None,\n        metadata: dict | None = None,\n    ) -&gt; AeromancyArtifact:\n        console.log(f\"FakeTracker output filenames: {local_filenames!r}\")\n        if metadata:\n            console.log(f\"FakeTracker output metadata: {metadata!r}\")\n\n        # Convert each file to a fake VersionedS3Object.\n        s3_objects = []\n        for local_filename in local_filenames:\n            new_path = local_filename\n            if strip_prefix:\n                # Need a trailing slash since otherwise we end up with an absolute path.\n                new_path = str(new_path).removeprefix(str(strip_prefix) + \"/\")\n            versioned_s3_object = VersionedS3Object(\n                s3_destination.bucket,\n                (s3_destination / new_path).key,\n                FAKE_VERSION,  # TODO: support multiple versions\n            )\n            s3_objects.append(versioned_s3_object)\n\n            # Actually store the files in the fake cache (if not already\n            # present). In this weird case, we already know the version, but we\n            # can use get_version() to find out if there's an existing cache\n            # entry.\n            sha1 = file_digest(local_filename)\n            existing_version_id = self.cache.get_version(\n                s3_object=versioned_s3_object,\n                sha1=sha1,\n            )\n            if existing_version_id is None:\n                console.log(\n                    f\"[OFFLINE] Pretending to store {str(local_filename)!r} to \"\n                    f\"{versioned_s3_object}\",\n                )\n                cached_path = self.cache.get_path(versioned_s3_object)\n                if cached_path.exists():\n                    # Temporarily make it writable again since\n                    # finalize_adding_file should have locked it down when it\n                    # was last added.\n                    cached_path.chmod(0o700)\n                shutil.copy(local_filename, cached_path)\n\n                self.cache.finalize_adding_file(\n                    cached_filename=cached_path,\n                    s3_object=versioned_s3_object,\n                    sha1=sha1,\n                )\n            else:\n                console.log(f\"Cache hit for {str(local_filename)!r})\")\n\n        # We now have enough to make an AeromancyArtifact.\n        aero_artifact = AeromancyArtifact(\n            name=name,\n            artifact_type=artifact_type,\n            s3=s3_objects,\n        )\n        artifact_name = WandbArtifactName(\n            entity=FAKE_ENTITY,\n            project=self.project_name,\n            artifact_name=name,\n            version=FAKE_VERSION,\n        )\n        self._set_artifact_mapping(artifact_name, aero_artifact)\n\n        return aero_artifact\n\n    @override\n    def declare_input(\n        self,\n        artifact: AeromancyArtifact | str,\n        use_as: str | None = None,\n    ) -&gt; Sequence[Path]:\n        if isinstance(artifact, str):\n            artifact_name = WandbArtifactName.parse(artifact)\n            # Basic version resolution\n            if artifact_name.version == \"latest\":\n                artifact_name.version = FAKE_VERSION\n            if artifact_name.project is None:\n                artifact_name.project = self.project_name\n            # We don't support sharing artifacts across entities, so we'll\n            # always mask out the entity name.\n            artifact_name.entity = FAKE_ENTITY\n            artifact = self.artifact_mapping.artifacts_by_name[str(artifact_name)]\n\n        local_paths = [\n            self.cache.get_path(s3, create_parents=False) for s3 in artifact.s3\n        ]\n        console.log(f\"FakeTracker input: {artifact!r} \u2192 {len(local_paths)} paths\")\n        return local_paths\n\n    @override\n    def log(self, metrics: dict[str, Any]) -&gt; None:\n        console.log(\"FakeTracker logged metrics:\", metrics)\n</code></pre>"},{"location":"reference/aeromancy/fake_tracker/#aeromancy.fake_tracker.bailout","title":"<code>bailout()</code>","text":"<p>Exit Aeromancy immediately (for quick debugging).</p> <p>This is primarily intended for <code>--dev</code> mode where it will avoid the extensive tracebacks we normally show. If run outside of <code>--dev</code> mode, it will still exit Aeromancy (but consider a more descriptive error).</p> Source code in <code>aeromancy/fake_tracker.py</code> <pre><code>def bailout():\n    \"\"\"Exit Aeromancy immediately (for quick debugging).\n\n    This is primarily intended for `--dev` mode where it will avoid the\n    extensive tracebacks we normally show. If run outside of `--dev` mode, it\n    will still exit Aeromancy (but consider a more descriptive error).\n    \"\"\"\n    raise _BailoutError\n</code></pre>"},{"location":"reference/aeromancy/rerun/","title":"rerun","text":"<p>Script to rerun an existing Aeromancy run.</p> <p>Run with:</p> <pre><code>shell&gt; pdm aeroview &lt;Weights and Biases run name&gt;\n</code></pre> <p>After it creates a Git repo for that run, it will provide instructions for how to rerun.</p>"},{"location":"reference/aeromancy/rerun/#aeromancy.rerun.checkout_git_commit","title":"<code>checkout_git_commit(git_remote, git_commit, checkout_dir, branch_name)</code>","text":"<p>Checkout a specific Git commit into a local directory.</p> <p>Parameters:</p> Name Type Description Default <code>git_remote</code> <p>URL to Git repository.</p> required <code>git_commit</code> <p>Specific commit to checkout from <code>git_remote</code></p> required <code>checkout_dir</code> <p>Directory for checkout of <code>git_remote</code></p> required <code>branch_name</code> <p>Name of branch in the checkout to point to <code>git_commit</code></p> required Source code in <code>aeromancy/rerun.py</code> <pre><code>def checkout_git_commit(git_remote, git_commit, checkout_dir, branch_name):\n    \"\"\"Checkout a specific Git commit into a local directory.\n\n    Parameters\n    ----------\n    git_remote\n        URL to Git repository.\n    git_commit\n        Specific commit to checkout from `git_remote`\n    checkout_dir\n        Directory for checkout of `git_remote`\n    branch_name\n        Name of branch in the checkout to point to `git_commit`\n    \"\"\"\n    repo = Repo.clone_from(git_remote, to_path=checkout_dir)\n\n    # Switch to the commit used in the run.\n    # Confused? See https://gitpython.readthedocs.io/en/stable/tutorial.html#switching-branches\n    rerun_branch = repo.create_head(branch_name, git_commit)\n    repo.head.reference = rerun_branch\n    if repo.head.is_detached:\n        raise ValueError(f\"Repo head is detached: {repo}\")\n    # Reset the index and working tree to match the pointed-to commit\n    repo.head.reset(index=True, working_tree=True)\n</code></pre>"},{"location":"reference/aeromancy/rerun/#aeromancy.rerun.fetch_metadata_for_run","title":"<code>fetch_metadata_for_run(run_path)</code>","text":"<p>Extract information for how to rerun a run from Weights and Biases.</p> <p>Parameters:</p> Name Type Description Default <code>run_path</code> <code>str</code> <p>Any string that Weights and Biases will parse as a run name. Typically something like <code>orgname/projectname/runname</code> where <code>runname</code> is a string of alphanumeric characters.</p> required <p>Returns:</p> Type Description <code>    Key information for how to rerun `run_path` with the same state, code, etc.</code> Source code in <code>aeromancy/rerun.py</code> <pre><code>def fetch_metadata_for_run(run_path: str) -&gt; _RerunDetails:\n    \"\"\"Extract information for how to rerun a run from Weights and Biases.\n\n    Parameters\n    ----------\n    run_path\n        Any string that Weights and Biases will parse as a run name. Typically\n        something like `orgname/projectname/runname` where `runname` is a string\n        of alphanumeric characters.\n\n    Returns\n    -------\n        Key information for how to rerun `run_path` with the same state, code, etc.\n    \"\"\"\n    wandb_api = wandb.Api()\n    run = wandb_api.run(run_path)\n\n    try:\n        git_metadata = run.metadata[\"git\"]\n        git_commit = git_metadata[\"commit\"]\n        git_remote = git_metadata[\"remote\"]\n    except KeyError as ke:\n        raise KeyError(\"Couldn't find git metadata in Weights and Biases run\") from ke\n\n    artifact_names = [\n        used_artifact.source_qualified_name\n        for used_artifact in run.used_artifacts()\n        if used_artifact.type != \"job\"\n    ]\n\n    return _RerunDetails(git_commit, git_remote, run.id, artifact_names)\n</code></pre>"},{"location":"reference/aeromancy/rerun/#aeromancy.rerun.rerun","title":"<code>rerun(run)</code>","text":"<p>Rerun a specific Weights and Biases run.</p> <p>RUN is the name of Weights and Biases Run to rerun. Typical names look like <code>org/project/alphanumericchars</code> though often parts of Weights &amp; Biases run URLs can be used, e.g., <code>`org/project/runs/alphanumericchars</code>.</p> Source code in <code>aeromancy/rerun.py</code> <pre><code>@click.command(context_settings=CLICK_CONTEXT_SETTINGS, no_args_is_help=True)\n@click.argument(\"run\")\ndef rerun(run: str) -&gt; None:\n    \"\"\"Rerun a specific Weights and Biases run.\n\n    RUN is the name of Weights and Biases Run to rerun. Typical names look like\n    `org/project/alphanumericchars` though often parts of Weights &amp; Biases run URLs can\n    be used, e.g., ``org/project/runs/alphanumericchars`.\n    \"\"\"\n    console.rule(f\"Rerunning Weights and Biases run {run!r}\")\n    rerun_details = fetch_metadata_for_run(run)\n    console.log(\"Rerun details:\", rerun_details)\n    git_commit = rerun_details.git_commit\n    git_remote = rerun_details.git_remote\n\n    console.rule(f\"Cloning commit {git_commit!r} from {git_remote}\")\n    checkout_dir = tempfile.mkdtemp(prefix=f\"rerun-{rerun_details.wandb_id}-\")\n    console.log(\"Checkout directory:\", checkout_dir)\n    checkout_git_commit(git_remote, git_commit, checkout_dir, \"rerun_branch\")\n\n    console.log(\"Installing PDM dependencies\")\n    subprocess.check_call([\"pdm\", \"install\"], cwd=checkout_dir)  # noqa: S607\n\n    artifact_flags = [\n        f\"--artifact-override {artifact_name}\"\n        for artifact_name in rerun_details.artifact_names\n    ]\n    artifact_flags_str = \"\"\n    if artifact_flags:\n        artifact_flags_str = \" \\\\\\n\\t\".join([\"\", *artifact_flags])\n    console.log(\"Rerun with:\")\n    # No console.log() here since it will include line numbers and make copy-paste\n    # messy.\n    print(f\"  cd {checkout_dir} &amp;&amp; pdm go{artifact_flags_str}\")\n</code></pre>"},{"location":"reference/aeromancy/runner/","title":"runner","text":"<p>Main entry point for Aeromancy.</p> <p>This takes care of building/checking the Aeromancy environment and running Aeromancy code properly.</p> <p>You shouldn't ever need to run or call this directly -- the \"pdm go\" pdm script should be setup in pyproject.toml.</p>"},{"location":"reference/aeromancy/runner/#aeromancy.runner.build_docker","title":"<code>build_docker(docker_tag, extra_debian_packages, quiet=True)</code>","text":"<p>Build our Docker image for running experiments.</p> <p>Returns the hash of the Docker image.</p> Source code in <code>aeromancy/runner.py</code> <pre><code>def build_docker(\n    docker_tag: str,\n    extra_debian_packages: list[str],\n    quiet: bool = True,\n) -&gt; str:\n    \"\"\"Build our Docker image for running experiments.\n\n    Returns the hash of the Docker image.\n    \"\"\"\n    docker_commmand_pieces = [\n        \"docker\",\n        \"buildx\",\n        \"build\",\n        # Forward SSH authorization so we can access private repos.\n        \"--ssh=default=$SSH_AUTH_SOCK\",\n        # Add local project (i.e., not Aeromancy's repo) as a build context so\n        # we can copy project-specific files to the image.\n        \"--build-context\",\n        \"project=.\",\n    ]\n    if extra_debian_packages:\n        # Format with !r (repr()) to automatically handle spaces and escaping.\n        build_arg = f\"EXTRA_DEBIAN_PACKAGES={' '.join(extra_debian_packages)!r}\"\n        docker_commmand_pieces.extend((\"--build-arg\", build_arg))\n    if quiet:\n        docker_commmand_pieces.append(\"--quiet\")\n    docker_commmand_pieces.extend(\n        (\n            \"--tag\",\n            docker_tag,\n            \"ssh://git@github.com/quant-aq/aeromancy.git#v0.1.0:docker\",\n        ),\n    )\n    docker_command = \" \".join(docker_commmand_pieces)\n\n    console.log(f\"Running {docker_command!r}\", style=\"info\")\n    docker_status, docker_output = subprocess.getstatusoutput(docker_command)\n    if docker_status:\n        console.log(f\"Docker output: {docker_output}\", style=\"error\")\n        raise SystemExit(f\"Docker exited with {docker_status}\")\n    return docker_output.strip()\n</code></pre>"},{"location":"reference/aeromancy/runner/#aeromancy.runner.check_git_state","title":"<code>check_git_state()</code>","text":"<p>Ensure our git repo is set up properly for tracking.</p> Source code in <code>aeromancy/runner.py</code> <pre><code>def check_git_state() -&gt; None:\n    \"\"\"Ensure our git repo is set up properly for tracking.\"\"\"\n    if str(repo.active_branch) in (\"main\", \"master\"):\n        raise SystemExit(\n            \"Error: Switch to a non-main branch before running experiments.\",\n        )\n\n    # First, call `git diff` since it's well formatted.\n    if subprocess.call(\"/usr/bin/git diff --exit-code\", shell=True):  # noqa: S602\n        print()\n\n    if repo.is_dirty() or repo.untracked_files:\n        if repo.untracked_files:\n            console.log(\"Untracked files:\", style=\"warning\")\n            for filename in repo.untracked_files:\n                console.log(f\"  {filename}\", style=\"warning\")\n        console.log(\n            \"Error: You must checkin your code before starting a run.\",\n            style=\"error\",\n        )\n        raise SystemExit\n</code></pre>"},{"location":"reference/aeromancy/runner/#aeromancy.runner.interactive","title":"<code>interactive(command)</code>","text":"<p>Run interactive shell commands.</p> Source code in <code>aeromancy/runner.py</code> <pre><code>def interactive(command: str) -&gt; None:\n    \"\"\"Run interactive shell commands.\"\"\"\n    console.log(f\"Running {command.strip()!r}\", style=\"info\")\n    exit_code = subprocess.call(\n        command,\n        shell=True,  # noqa: S602\n        stdout=sys.stdout,\n        stderr=subprocess.STDOUT,\n    )\n    if exit_code:\n        console.log(f\"Exit code {exit_code} for {command!r}\", style=\"warning\")\n</code></pre>"},{"location":"reference/aeromancy/runner/#aeromancy.runner.main","title":"<code>main(debug_shell, dev, extra_docker_run_args, extra_debian_packages, extra_env_vars, artifact_overrides, extra_cmdline_args, debug, aeromain_path)</code>","text":"<p>Run Aeromancy as a CLI application.</p> Source code in <code>aeromancy/runner.py</code> <pre><code>@click.command(\n    context_settings={\n        \"ignore_unknown_options\": True,  # Extra options are passed through to Aeromain.\n        \"help_option_names\": [\"-h\", \"--help\"],\n    },\n)\n@runner_click_options\n@click.argument(\"extra_cmdline_args\", nargs=-1, type=click.UNPROCESSED)\ndef main(\n    debug_shell: bool,\n    dev: bool,\n    extra_docker_run_args: str,\n    extra_debian_packages: list[str],\n    extra_env_vars: list[str],\n    artifact_overrides: list[str],\n    extra_cmdline_args: list[str],\n    debug: bool,\n    aeromain_path: str,\n) -&gt; None:\n    \"\"\"Run Aeromancy as a CLI application.\"\"\"\n    if debug_shell or dev:\n        # These values aren't critical in development mode. We fill them in\n        # since an early Aeromancy project might not be completely set up with\n        # Git.\n        git_ref = docker_tag = \"development\"\n    else:\n        git_ref = str(repo.commit())\n        docker_tag = git_ref[:7]  # Keep it short for cleaner command lines.\n        check_git_state()\n\n    # Autoset debug mode when we're doing a debug_shell (these are separate\n    # options since we might want debug mode outside of a debug shell).\n    debug = debug or debug_shell\n\n    if dev:\n        docker_hash = NOT_IN_DOCKER\n    else:\n        docker_hash = build_docker(\n            docker_tag=docker_tag,\n            extra_debian_packages=extra_debian_packages,\n            quiet=not debug,\n        )\n    env_filename = store_environment_variables(\n        git_ref=git_ref,\n        docker_hash=docker_hash,\n        dev_mode=dev,\n        debug_mode=debug,\n        aeromancy_artifact_overrides=artifact_overrides,\n        extra_env_vars=extra_env_vars,\n    )\n\n    formatted_extra_cmdline_args = \" \".join(extra_cmdline_args)\n    if debug_shell:\n        docker_subcommand = f\"/bin/sh {formatted_extra_cmdline_args}\"\n    else:\n        docker_subcommand = (\n            f\"pdm run python {aeromain_path} {formatted_extra_cmdline_args}\"\n        )\n\n    if dev:\n        interactive(docker_subcommand)\n    else:\n        run_docker(env_filename, docker_tag, docker_subcommand, extra_docker_run_args)\n</code></pre>"},{"location":"reference/aeromancy/runner/#aeromancy.runner.run_docker","title":"<code>run_docker(env_filename, docker_tag, docker_subcommand, extra_docker_run_args)</code>","text":"<p>Run <code>docker run</code> with specified arguments.</p> Source code in <code>aeromancy/runner.py</code> <pre><code>def run_docker(\n    env_filename: str,\n    docker_tag: str,\n    docker_subcommand: str,\n    extra_docker_run_args: str,\n) -&gt; None:\n    \"\"\"Run `docker run` with specified arguments.\"\"\"\n    interactive(\n        f\"docker run --env-file {env_filename} -v ~/Cache:/root/Cache \"\n        f\"{extra_docker_run_args} -it {docker_tag} {docker_subcommand}\",\n    )\n</code></pre>"},{"location":"reference/aeromancy/runner/#aeromancy.runner.store_environment_variables","title":"<code>store_environment_variables(git_ref, docker_hash, dev_mode, debug_mode, aeromancy_artifact_overrides, extra_env_vars)</code>","text":"<p>Store git and Docker info in environment variables to pass to container.</p> <p>Returns path to an file to pass to Docker via --env-file.</p> Source code in <code>aeromancy/runner.py</code> <pre><code>def store_environment_variables(\n    git_ref: str,\n    docker_hash: str,\n    dev_mode: bool,\n    debug_mode: bool,\n    aeromancy_artifact_overrides: list[str],\n    extra_env_vars: list[str],\n) -&gt; str:\n    \"\"\"Store git and Docker info in environment variables to pass to container.\n\n    Returns path to an file to pass to Docker via --env-file.\n    \"\"\"\n    if dev_mode:\n        # Set some bogus values so we can operate in development mode with an\n        # incomplete Git repo setup.\n        message_lines = [\"development\"]\n        git_remote = \"https://github.com/some-valid-looking/git-repo-url.git\"\n    else:\n        message_lines = str(repo.commit().message).splitlines()\n        git_remote = next(repo.remote().urls)\n\n    # Show a truncated version of the first line.\n    message = message_lines[0]\n    if len(message_lines) &gt; 1:\n        message += \" (...)\"\n    loguru_diagnose = not dev_mode\n    updates: dict[str, str] = {\n        GIT_REF_ENV: git_ref,\n        GIT_MESSAGE_ENV: message,\n        GIT_REMOTE_ENV: git_remote,\n        GIT_BRANCH_ENV: str(repo.active_branch),\n        DOCKER_HASH_ENV: docker_hash,\n        AEROMANCY_ARTIFACT_OVERRIDES_ENV: \",\".join(aeromancy_artifact_overrides),\n        AEROMANCY_DEV_MODE_ENV: str(dev_mode),\n        AEROMANCY_DEBUG_MODE_ENV: str(debug_mode),\n        # Don't do loguru diagnose by default (can leak sensitive info in W&amp;B logs)\n        \"LOGURU_DIAGNOSE\": str(loguru_diagnose).lower(),\n    }\n    os.environ.update(updates)\n\n    # There's enough environment variables that they clutter the Docker commmand,\n    # so we store them in an --env-file.\n    all_passthrough_variables = PASSTHROUGH_ENV_VARIABLES + tuple(extra_env_vars)\n    env_file_path = Path(\".env_file\")\n    with env_file_path.open(\"w\") as env_file:\n        for key in tuple(updates.keys()) + all_passthrough_variables:\n            env_file.write(f\"{key}\\n\")\n    return str(env_file_path)\n</code></pre>"},{"location":"reference/aeromancy/runtime_environment/","title":"runtime_environment","text":"<p>Captures information about the runtime environment for Aeromancy.</p>"},{"location":"reference/aeromancy/runtime_environment/#aeromancy.runtime_environment.RuntimeEnvironment","title":"<code>RuntimeEnvironment</code>","text":"<p>Information about the runtime environment for Aeromancy.</p> <p>Note: You should not need to create one of these on your own. See <code>get_runtime_environment</code>.</p> Source code in <code>aeromancy/runtime_environment.py</code> <pre><code>class RuntimeEnvironment:\n    \"\"\"Information about the runtime environment for Aeromancy.\n\n    Note: You should not need to create one of these on your own. See\n    `get_runtime_environment`.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Determine the current runtime environment.\"\"\"\n        self.docker_hash = env.get(DOCKER_HASH_ENV)\n        if not self.docker_hash or self.docker_hash == NOT_IN_DOCKER:\n            self.docker_hash = None\n\n        # When running in dev mode, we use FakeTracker and avoid any calls\n        # to W&amp;B or S3.\n        self.dev_mode = env.get(AEROMANCY_DEV_MODE_ENV, \"\").lower() == \"true\"\n\n        # Debug mode makes us more verbose about Aeromancy internals. It's\n        # primarily used for debugging Aeromancy itself or in conjunction with\n        # dev mode while performing development in an Aeromancy project.\n        self.debug_mode = env.get(AEROMANCY_DEBUG_MODE_ENV, \"\").lower() == \"true\"\n\n        # Offline mode means we should avoid any sort of network access. It's currently\n        # only triggered by dev mode.\n        self.offline = self.dev_mode\n\n        self.git_commit_hash = env.get(GIT_REF_ENV)\n        self._parse_git_remote()\n        self.git_message = env.get(GIT_MESSAGE_ENV)\n        self.git_branch = env.get(GIT_BRANCH_ENV)\n\n        # Parse artifact overrides (comma-separated list)\n        artifact_overrides_env = env.get(AEROMANCY_ARTIFACT_OVERRIDES_ENV, \"\")\n        self.artifact_overrides: list[str] = (\n            artifact_overrides_env.split(\",\") if artifact_overrides_env else []\n        )\n\n    def _parse_git_remote(self):\n        \"\"\"Parse Git remote URL (if available).\"\"\"\n        self.git_remote_url = env.get(GIT_REMOTE_ENV)\n        self.git_repo_name = None\n\n        with suppress(ValueError, TypeError):\n            parsed = giturlparse.parse(self.git_remote_url)\n            if parsed.valid:\n                self.git_repo_name = parsed.data.get(\"repo\")\n\n        if not self.git_repo_name:\n            message = f\"Couldn't parse Git remote URL: {self.git_remote_url!r}\"\n            if self.dev_mode:\n                # Let them off with a warning, since results won't be logged anyway.\n                logger.warning(message)\n            else:\n                raise ValueError(message)\n\n    def confirm_running_from_container(self) -&gt; None:\n        \"\"\"Gut check to ensure Aeromancy main scripts aren't run directly.\"\"\"\n        if self.dev_mode:\n            # Development mode lets you bypass this check.\n            return\n\n        if not (self.docker_hash and self.git_commit_hash):\n            # TODO: point to appropriate docs\n            raise SystemExit(\n                \"Error: Aeromancy Trackers can only be used when running in a \"\n                \"Docker container.\",\n            )\n</code></pre>"},{"location":"reference/aeromancy/runtime_environment/#aeromancy.runtime_environment.RuntimeEnvironment.__init__","title":"<code>__init__()</code>","text":"<p>Determine the current runtime environment.</p> Source code in <code>aeromancy/runtime_environment.py</code> <pre><code>def __init__(self):\n    \"\"\"Determine the current runtime environment.\"\"\"\n    self.docker_hash = env.get(DOCKER_HASH_ENV)\n    if not self.docker_hash or self.docker_hash == NOT_IN_DOCKER:\n        self.docker_hash = None\n\n    # When running in dev mode, we use FakeTracker and avoid any calls\n    # to W&amp;B or S3.\n    self.dev_mode = env.get(AEROMANCY_DEV_MODE_ENV, \"\").lower() == \"true\"\n\n    # Debug mode makes us more verbose about Aeromancy internals. It's\n    # primarily used for debugging Aeromancy itself or in conjunction with\n    # dev mode while performing development in an Aeromancy project.\n    self.debug_mode = env.get(AEROMANCY_DEBUG_MODE_ENV, \"\").lower() == \"true\"\n\n    # Offline mode means we should avoid any sort of network access. It's currently\n    # only triggered by dev mode.\n    self.offline = self.dev_mode\n\n    self.git_commit_hash = env.get(GIT_REF_ENV)\n    self._parse_git_remote()\n    self.git_message = env.get(GIT_MESSAGE_ENV)\n    self.git_branch = env.get(GIT_BRANCH_ENV)\n\n    # Parse artifact overrides (comma-separated list)\n    artifact_overrides_env = env.get(AEROMANCY_ARTIFACT_OVERRIDES_ENV, \"\")\n    self.artifact_overrides: list[str] = (\n        artifact_overrides_env.split(\",\") if artifact_overrides_env else []\n    )\n</code></pre>"},{"location":"reference/aeromancy/runtime_environment/#aeromancy.runtime_environment.RuntimeEnvironment.confirm_running_from_container","title":"<code>confirm_running_from_container()</code>","text":"<p>Gut check to ensure Aeromancy main scripts aren't run directly.</p> Source code in <code>aeromancy/runtime_environment.py</code> <pre><code>def confirm_running_from_container(self) -&gt; None:\n    \"\"\"Gut check to ensure Aeromancy main scripts aren't run directly.\"\"\"\n    if self.dev_mode:\n        # Development mode lets you bypass this check.\n        return\n\n    if not (self.docker_hash and self.git_commit_hash):\n        # TODO: point to appropriate docs\n        raise SystemExit(\n            \"Error: Aeromancy Trackers can only be used when running in a \"\n            \"Docker container.\",\n        )\n</code></pre>"},{"location":"reference/aeromancy/runtime_environment/#aeromancy.runtime_environment.get_runtime_environment","title":"<code>get_runtime_environment()</code>","text":"<p>Fetch the <code>RuntimeEnvironment</code> global.</p> <p>This is created on demand and reuses existing instances.</p> Source code in <code>aeromancy/runtime_environment.py</code> <pre><code>def get_runtime_environment() -&gt; RuntimeEnvironment:\n    \"\"\"Fetch the `RuntimeEnvironment` global.\n\n    This is created on demand and reuses existing instances.\n    \"\"\"\n    global _runtime_environment\n    if not _runtime_environment:\n        _runtime_environment = RuntimeEnvironment()\n    return _runtime_environment\n</code></pre>"},{"location":"reference/aeromancy/s3/","title":"s3","text":"<p>Opinionated S3 interface which forces versioning and local caching.</p> <p>Terminological note: We use the term \"pseudodirectory\" when describing portions of S3 paths that look like directories, but aren't because S3 isn't actually a filesystem. For example, in the key \"a/b/c\", we would say that \"c\" is the in pseudodirectory \"a/b\".</p>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.Cache","title":"<code>Cache</code>","text":"<p>Interface to local cache of S3 objects.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>class Cache:\n    \"\"\"Interface to local cache of S3 objects.\"\"\"\n\n    def __init__(self, cache_root: Path):\n        \"\"\"Create the cache interface.\n\n        Parameters\n        ----------\n        cache_root\n            Top level directory for the cache.\n        \"\"\"\n        self._cache_root = cache_root.expanduser().resolve()\n        self._checksum_path = self._cache_root / \"checksums.json\"\n        self._cacheentry_by_checksum = self._load_checksums()\n\n    def _load_checksums(self) -&gt; dict[str, list[CacheEntry]]:\n        if not self._checksum_path.exists():\n            return defaultdict(list)\n\n        checksum_bytes = self._checksum_path.read_bytes()\n        cache_entries = msgspec.json.decode(checksum_bytes, type=list[CacheEntry])\n\n        # There may be multiple CacheEntry objects for a single checksum.\n        # Hash collisions are quite possible with identical files.\n        entries_by_checksum = defaultdict(list)\n        for entry in cache_entries:\n            entries_by_checksum[entry.checksum_sha1].append(entry)\n\n        return entries_by_checksum\n\n    def _save_checksums(self) -&gt; None:\n        all_entries = []\n        for entries in self._cacheentry_by_checksum.values():\n            all_entries.extend(entries)\n        # Sort by repr() since entries can be mixed between S3Object and\n        # VersionedS3Object which don't compare with each other. This is purely\n        # to improve human readability of the resulting JSON -- nothing relies\n        # on this ordering.\n        all_entries.sort(key=lambda entry: repr(entry))\n        jsonified = msgspec.json.encode(all_entries)\n\n        self._cache_root.mkdir(parents=True, exist_ok=True)\n        with self._checksum_path.open(\"wb\") as checksums:\n            checksums.write(jsonified)\n\n    def get_path(\n        self,\n        s3_object: S3Object | VersionedS3Object,\n        create_parents: bool = True,\n    ) -&gt; Path:\n        \"\"\"Return storage location in our local cache for an object.\"\"\"\n        path_pieces = [s3_object.bucket, s3_object.key]\n        if isinstance(s3_object, VersionedS3Object):\n            path_pieces.append(s3_object.version_id)\n\n        cached_filename: Path = self._cache_root.joinpath(*path_pieces)\n        if create_parents:\n            cached_filename.parent.mkdir(parents=True, exist_ok=True)\n        return cached_filename\n\n    def get_version(self, s3_object: S3Object, sha1: str) -&gt; str | None:\n        \"\"\"Check if a specific SHA1 checksum for an `S3Object` is already in the cache.\n\n        Parameters\n        ----------\n        s3_object\n            The S3 object in question.\n        sha1\n            Checksum for an object to check.\n\n        Returns\n        -------\n            Returns the S3 version as a string if the checksum was found for\n            that S3 object, otherwise None.\n        \"\"\"\n        entries: list[CacheEntry] = self._cacheentry_by_checksum.get(sha1, [])\n        for entry in entries:\n            if entry.s3_object != s3_object:\n                continue\n\n            # We've found the CacheEntry which matches checksum for this\n            # s3_object. Last part of a cached filename is the version_id\n            # (except when allow_unversioned=True, but these objects should\n            # never use this code path and allow_unversioned is not supported\n            # for other uses).\n            return Path(entry.cached_filename).parts[-1]\n\n        # No matching entries found.\n        return None\n\n    def finalize_adding_file(\n        self,\n        cached_filename: Path,\n        s3_object: S3Object,\n        last_modified: datetime | None = None,\n        sha1: str | None = None,\n    ):\n        \"\"\"Must be called whenever an item is added to the cache.\n\n        Optionally helps you set its modification time.\n        sha1 can be provided if already calculated.\n        \"\"\"\n        if last_modified:\n            last_modified_tuple = time.mktime(last_modified.timetuple())\n            os.utime(cached_filename, (last_modified_tuple, last_modified_tuple))\n\n        # Make cache files read only.\n        cached_filename.chmod(0o400)\n\n        self._make_cacheentry(\n            cached_filename=cached_filename,\n            s3_object=s3_object,\n            sha1=sha1,\n        )\n        self._save_checksums()\n\n    def _make_cacheentry(\n        self,\n        cached_filename: Path,\n        s3_object: S3Object,\n        sha1: str | None = None,\n    ):\n        if sha1 is None:\n            sha1 = file_digest(cached_filename)\n\n        entry = CacheEntry(\n            s3_object=s3_object,\n            checksum_sha1=sha1,\n            cached_filename=str(cached_filename),\n        )\n        self._cacheentry_by_checksum[sha1].append(entry)\n\n    def repair(self) -&gt; None:\n        \"\"\"Delete and regenerate the checksum cache.\"\"\"\n        self._cacheentry_by_checksum.clear()\n        for filename in sorted(self._cache_root.glob(\"**/*\")):\n            # Skip files in the root of the cache directory (these are cache\n            # metadata).\n            if not filename.is_file() or filename.parent == self._cache_root:\n                continue\n            logger.info(f\"Checksumming {str(filename)!r}\")\n            relative_filename = Path(str(filename).replace(f\"{self._cache_root}/\", \"\"))\n            [bucket, *key_parts, version_id] = relative_filename.parts\n            key = \"/\".join(key_parts)\n            self._make_cacheentry(\n                cached_filename=filename,\n                s3_object=S3Object(bucket=bucket, key=key),\n            )\n        self._save_checksums()\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.Cache.__init__","title":"<code>__init__(cache_root)</code>","text":"<p>Create the cache interface.</p> <p>Parameters:</p> Name Type Description Default <code>cache_root</code> <code>Path</code> <p>Top level directory for the cache.</p> required Source code in <code>aeromancy/s3.py</code> <pre><code>def __init__(self, cache_root: Path):\n    \"\"\"Create the cache interface.\n\n    Parameters\n    ----------\n    cache_root\n        Top level directory for the cache.\n    \"\"\"\n    self._cache_root = cache_root.expanduser().resolve()\n    self._checksum_path = self._cache_root / \"checksums.json\"\n    self._cacheentry_by_checksum = self._load_checksums()\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.Cache.finalize_adding_file","title":"<code>finalize_adding_file(cached_filename, s3_object, last_modified=None, sha1=None)</code>","text":"<p>Must be called whenever an item is added to the cache.</p> <p>Optionally helps you set its modification time. sha1 can be provided if already calculated.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def finalize_adding_file(\n    self,\n    cached_filename: Path,\n    s3_object: S3Object,\n    last_modified: datetime | None = None,\n    sha1: str | None = None,\n):\n    \"\"\"Must be called whenever an item is added to the cache.\n\n    Optionally helps you set its modification time.\n    sha1 can be provided if already calculated.\n    \"\"\"\n    if last_modified:\n        last_modified_tuple = time.mktime(last_modified.timetuple())\n        os.utime(cached_filename, (last_modified_tuple, last_modified_tuple))\n\n    # Make cache files read only.\n    cached_filename.chmod(0o400)\n\n    self._make_cacheentry(\n        cached_filename=cached_filename,\n        s3_object=s3_object,\n        sha1=sha1,\n    )\n    self._save_checksums()\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.Cache.get_path","title":"<code>get_path(s3_object, create_parents=True)</code>","text":"<p>Return storage location in our local cache for an object.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def get_path(\n    self,\n    s3_object: S3Object | VersionedS3Object,\n    create_parents: bool = True,\n) -&gt; Path:\n    \"\"\"Return storage location in our local cache for an object.\"\"\"\n    path_pieces = [s3_object.bucket, s3_object.key]\n    if isinstance(s3_object, VersionedS3Object):\n        path_pieces.append(s3_object.version_id)\n\n    cached_filename: Path = self._cache_root.joinpath(*path_pieces)\n    if create_parents:\n        cached_filename.parent.mkdir(parents=True, exist_ok=True)\n    return cached_filename\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.Cache.get_version","title":"<code>get_version(s3_object, sha1)</code>","text":"<p>Check if a specific SHA1 checksum for an <code>S3Object</code> is already in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>s3_object</code> <code>S3Object</code> <p>The S3 object in question.</p> required <code>sha1</code> <code>str</code> <p>Checksum for an object to check.</p> required <p>Returns:</p> Type Description <code>    Returns the S3 version as a string if the checksum was found for</code> <p>that S3 object, otherwise None.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def get_version(self, s3_object: S3Object, sha1: str) -&gt; str | None:\n    \"\"\"Check if a specific SHA1 checksum for an `S3Object` is already in the cache.\n\n    Parameters\n    ----------\n    s3_object\n        The S3 object in question.\n    sha1\n        Checksum for an object to check.\n\n    Returns\n    -------\n        Returns the S3 version as a string if the checksum was found for\n        that S3 object, otherwise None.\n    \"\"\"\n    entries: list[CacheEntry] = self._cacheentry_by_checksum.get(sha1, [])\n    for entry in entries:\n        if entry.s3_object != s3_object:\n            continue\n\n        # We've found the CacheEntry which matches checksum for this\n        # s3_object. Last part of a cached filename is the version_id\n        # (except when allow_unversioned=True, but these objects should\n        # never use this code path and allow_unversioned is not supported\n        # for other uses).\n        return Path(entry.cached_filename).parts[-1]\n\n    # No matching entries found.\n    return None\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.Cache.repair","title":"<code>repair()</code>","text":"<p>Delete and regenerate the checksum cache.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def repair(self) -&gt; None:\n    \"\"\"Delete and regenerate the checksum cache.\"\"\"\n    self._cacheentry_by_checksum.clear()\n    for filename in sorted(self._cache_root.glob(\"**/*\")):\n        # Skip files in the root of the cache directory (these are cache\n        # metadata).\n        if not filename.is_file() or filename.parent == self._cache_root:\n            continue\n        logger.info(f\"Checksumming {str(filename)!r}\")\n        relative_filename = Path(str(filename).replace(f\"{self._cache_root}/\", \"\"))\n        [bucket, *key_parts, version_id] = relative_filename.parts\n        key = \"/\".join(key_parts)\n        self._make_cacheentry(\n            cached_filename=filename,\n            s3_object=S3Object(bucket=bucket, key=key),\n        )\n    self._save_checksums()\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.CacheEntry","title":"<code>CacheEntry</code>","text":"<p>             Bases: <code>Struct</code></p> <p>Single S3 cache entry.</p> <p>The format of this should not be relied on and subject to change.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>class CacheEntry(msgspec.Struct, order=True):\n    \"\"\"Single S3 cache entry.\n\n    The format of this should not be relied on and subject to change.\n    \"\"\"\n\n    s3_object: S3Object\n    cached_filename: str\n    checksum_sha1: str\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Bucket","title":"<code>S3Bucket</code>","text":"<p>             Bases: <code>Struct</code></p> <p>Represents an S3 bucket.</p> <p>Attributes:</p> Name Type Description <code>bucket</code> <code>str</code> <p>Name of an S3 bucket.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>class S3Bucket(msgspec.Struct, frozen=True):\n    \"\"\"Represents an S3 bucket.\n\n    Attributes\n    ----------\n    bucket\n        Name of an S3 bucket.\n    \"\"\"\n\n    bucket: str\n\n    def __str__(self):\n        \"\"\"Return the name of the bucket.\"\"\"\n        return str(self.bucket)\n\n    def __getitem__(self, key: str) -&gt; \"S3Object\":\n        \"\"\"Create an S3Object for this bucket with the specified key.\"\"\"\n        return S3Object(self.bucket, key)\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Bucket.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Create an S3Object for this bucket with the specified key.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def __getitem__(self, key: str) -&gt; \"S3Object\":\n    \"\"\"Create an S3Object for this bucket with the specified key.\"\"\"\n    return S3Object(self.bucket, key)\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Bucket.__str__","title":"<code>__str__()</code>","text":"<p>Return the name of the bucket.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def __str__(self):\n    \"\"\"Return the name of the bucket.\"\"\"\n    return str(self.bucket)\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client","title":"<code>S3Client</code>","text":"<p>An S3 client that is version-aware and caches objects to disk.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>class S3Client:\n    \"\"\"An S3 client that is version-aware and caches objects to disk.\"\"\"\n\n    def __init__(\n        self,\n        region_name,\n        endpoint_url,\n        aws_access_key_id,\n        aws_secret_access_key,\n        cache_root=\"~/Cache/\",\n    ):\n        \"\"\"Create a client for working with S3 storage.\n\n        region_name, endpoint_url, aws_access_key_id, aws_secret_access_key are passed\n        directly to boto3.client.\n\n        cache_root is where our bucket cache should live on disk. By default, it\n        persists in your home directory.\n        \"\"\"\n        self._s3_client = boto3.client(\n            \"s3\",\n            region_name=region_name,\n            endpoint_url=endpoint_url,\n            aws_access_key_id=aws_access_key_id,\n            aws_secret_access_key=aws_secret_access_key,\n        )\n        self.cache = Cache(Path(cache_root))\n\n    @classmethod\n    def from_env_variables(cls):\n        \"\"\"Construct an instance from environment variables.\n\n        If one has already been constructed, we will reuse it (assumes that\n        environment variables don't change).\n        \"\"\"\n        global _S3_CLIENT\n        if not _S3_CLIENT:\n            _S3_CLIENT = cls(\n                aws_access_key_id=os.environ[\"AEROMANCY_AWS_ACCESS_KEY_ID\"],\n                aws_secret_access_key=os.environ[\"AEROMANCY_AWS_SECRET_ACCESS_KEY\"],\n                region_name=os.environ[\"AEROMANCY_AWS_REGION\"],\n                endpoint_url=os.environ[\"AEROMANCY_AWS_S3_ENDPOINT_URL\"],\n            )\n        return _S3_CLIENT\n\n    def latest_version(self, s3_object: S3Object) -&gt; str:\n        \"\"\"Return the latest version ID for an object.\n\n        Raises a TypeError if s3_object doesn't have a version.\n        \"\"\"\n        response = self._s3_client.get_object(\n            Bucket=s3_object.bucket,\n            Key=s3_object.key,\n        )\n        try:\n            return response[\"VersionId\"]\n        except KeyError as err:\n            raise TypeError(\n                f\"s3_object has no version information: {s3_object!r}\",\n            ) from err\n\n    def fetch(self, s3_object: S3Object, allow_unversioned=False) -&gt; Path:\n        \"\"\"Return the path to a local copy of an object from a bucket.\n\n        If the object is not already in our cache, we'll download it.\n\n        CAUTION: You can fetch unversioned S3Objects with allow_unversioned=True\n        but this should be avoided whenever possible and assumes you know what\n        you're doing. These will not be redownloaded unless manually deleted.\n\n        Returns the path to the cached filename.\n        \"\"\"\n        versioned = isinstance(s3_object, VersionedS3Object)\n        if not versioned and not allow_unversioned:\n            raise ValueError(\n                f\"Won't fetch an unversioned S3Object ({s3_object}) unless \"\n                \"allow_unversioned=True (use caution!)\",\n            )\n\n        # Determine where it should live in the cache. Note the key will\n        # actually become a directory here so we can group all its versions\n        # together.\n        cached_filename: Path = self.cache.get_path(s3_object)\n        if cached_filename.exists():\n            return cached_filename\n\n        logger.info(f\"Fetching and caching {s3_object!r}\")\n\n        # Actually download the file.\n        download_kwargs = {}\n        if versioned:\n            download_kwargs[\"ExtraArgs\"] = {\"VersionId\": s3_object.version_id}\n        self._s3_client.download_file(\n            s3_object.bucket,\n            s3_object.key,\n            cached_filename,\n            **download_kwargs,\n        )\n\n        # Set modification (and access) time to S3's modification time. This\n        # helps with debugging and also means they'll sort by version easily\n        # with tools like \"ls -lt\".\n        get_object_kwargs = {}\n        if versioned:\n            get_object_kwargs[\"VersionId\"] = s3_object.version_id\n        response = self._s3_client.get_object(\n            Bucket=s3_object.bucket,\n            Key=s3_object.key,\n            **get_object_kwargs,\n        )\n        last_modified: datetime = response[\"LastModified\"]\n\n        self.cache.finalize_adding_file(\n            cached_filename=cached_filename,\n            s3_object=s3_object,\n            last_modified=last_modified,\n        )\n        return cached_filename\n\n    def put(\n        self,\n        local_filename: Path,\n        s3_object: S3Object,\n    ) -&gt; VersionedS3Object:\n        \"\"\"Upload a local file to S3 and stores it in the cache.\n\n        Returns a versioned copy of s3_object.\n        \"\"\"\n        # Check if we already have this file.\n        sha1 = file_digest(local_filename)\n        size = humanize.naturalsize(local_filename.stat().st_size)\n        existing_version_id = self.cache.get_version(s3_object=s3_object, sha1=sha1)\n        if existing_version_id is None:\n            logger.info(f\"Storing {str(local_filename)!r} ({size}) to {s3_object}\")\n            self._s3_client.upload_file(local_filename, s3_object.bucket, s3_object.key)\n            # TODO: there's a potential race condition here if two uploads of the same\n            # file happens simultaneously.\n            version_id = self.latest_version(s3_object)\n        else:\n            logger.info(\n                f\"Cache hit for {str(local_filename)!r} ({size}), skipping upload to \"\n                f\"{s3_object}\",\n            )\n            version_id = existing_version_id\n\n        versioned_s3_object = VersionedS3Object(\n            **s3_object.to_dict(),\n            version_id=version_id,\n        )\n\n        # Transfer it to the cache if it's not already there.\n        if not existing_version_id:\n            cached_filename = self.cache.get_path(versioned_s3_object)\n            shutil.copy(local_filename, cached_filename)\n\n            self.cache.finalize_adding_file(\n                s3_object=s3_object,\n                cached_filename=cached_filename,\n                sha1=sha1,\n            )\n\n        return versioned_s3_object\n\n    def list_versions(self, s3_object: VersionedS3Object) -&gt; list[str]:\n        \"\"\"Return a list of all versions of a specific key in a bucket.\n\n        Versions are sorted from oldest to newest (according to S3).\n        \"\"\"\n        version_iter = version_iterator(\n            self._s3_client,\n            s3_object.bucket,\n            s3_object.key,\n        )\n        mtime_and_versions: list[tuple[datetime, str]] = [\n            (version[\"LastModified\"], version[\"VersionId\"]) for version in version_iter\n        ]\n        return [version_id for _, version_id in sorted(mtime_and_versions)]\n\n    def list_objects(\n        self,\n        bucket: S3Bucket | str,\n        pseudodirectory: str,\n    ) -&gt; list[S3Object]:\n        \"\"\"Return a list of all keys that match a prefix in a bucket.\n\n        This assumes that prefix is a (pseudo)directory and will only include\n        \"children\" of that directory and not the directory itself.\n\n        Keys are sorted by standard Python string ordering.\n        \"\"\"\n        if not pseudodirectory.endswith(\"/\"):\n            pseudodirectory += \"/\"\n\n        all_keys = sorted(\n            list_objects_iterator(self._s3_client, str(bucket), pseudodirectory),\n        )\n        return [\n            S3Object(str(bucket), key) for key in all_keys if key != pseudodirectory\n        ]\n\n    def ensure_object_versioning(self, bucket: S3Bucket | str) -&gt; None:\n        \"\"\"Make sure that a bucket has object versioning enabled.\n\n        This only needs to be run once per bucket.\n        \"\"\"\n        self._s3_client.put_bucket_versioning(\n            Bucket=str(bucket),\n            VersioningConfiguration={\n                \"Status\": \"Enabled\",\n            },\n        )\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client.__init__","title":"<code>__init__(region_name, endpoint_url, aws_access_key_id, aws_secret_access_key, cache_root='~/Cache/')</code>","text":"<p>Create a client for working with S3 storage.</p> <p>region_name, endpoint_url, aws_access_key_id, aws_secret_access_key are passed directly to boto3.client.</p> <p>cache_root is where our bucket cache should live on disk. By default, it persists in your home directory.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def __init__(\n    self,\n    region_name,\n    endpoint_url,\n    aws_access_key_id,\n    aws_secret_access_key,\n    cache_root=\"~/Cache/\",\n):\n    \"\"\"Create a client for working with S3 storage.\n\n    region_name, endpoint_url, aws_access_key_id, aws_secret_access_key are passed\n    directly to boto3.client.\n\n    cache_root is where our bucket cache should live on disk. By default, it\n    persists in your home directory.\n    \"\"\"\n    self._s3_client = boto3.client(\n        \"s3\",\n        region_name=region_name,\n        endpoint_url=endpoint_url,\n        aws_access_key_id=aws_access_key_id,\n        aws_secret_access_key=aws_secret_access_key,\n    )\n    self.cache = Cache(Path(cache_root))\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client.ensure_object_versioning","title":"<code>ensure_object_versioning(bucket)</code>","text":"<p>Make sure that a bucket has object versioning enabled.</p> <p>This only needs to be run once per bucket.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def ensure_object_versioning(self, bucket: S3Bucket | str) -&gt; None:\n    \"\"\"Make sure that a bucket has object versioning enabled.\n\n    This only needs to be run once per bucket.\n    \"\"\"\n    self._s3_client.put_bucket_versioning(\n        Bucket=str(bucket),\n        VersioningConfiguration={\n            \"Status\": \"Enabled\",\n        },\n    )\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client.fetch","title":"<code>fetch(s3_object, allow_unversioned=False)</code>","text":"<p>Return the path to a local copy of an object from a bucket.</p> <p>If the object is not already in our cache, we'll download it.</p> <p>CAUTION: You can fetch unversioned S3Objects with allow_unversioned=True but this should be avoided whenever possible and assumes you know what you're doing. These will not be redownloaded unless manually deleted.</p> <p>Returns the path to the cached filename.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def fetch(self, s3_object: S3Object, allow_unversioned=False) -&gt; Path:\n    \"\"\"Return the path to a local copy of an object from a bucket.\n\n    If the object is not already in our cache, we'll download it.\n\n    CAUTION: You can fetch unversioned S3Objects with allow_unversioned=True\n    but this should be avoided whenever possible and assumes you know what\n    you're doing. These will not be redownloaded unless manually deleted.\n\n    Returns the path to the cached filename.\n    \"\"\"\n    versioned = isinstance(s3_object, VersionedS3Object)\n    if not versioned and not allow_unversioned:\n        raise ValueError(\n            f\"Won't fetch an unversioned S3Object ({s3_object}) unless \"\n            \"allow_unversioned=True (use caution!)\",\n        )\n\n    # Determine where it should live in the cache. Note the key will\n    # actually become a directory here so we can group all its versions\n    # together.\n    cached_filename: Path = self.cache.get_path(s3_object)\n    if cached_filename.exists():\n        return cached_filename\n\n    logger.info(f\"Fetching and caching {s3_object!r}\")\n\n    # Actually download the file.\n    download_kwargs = {}\n    if versioned:\n        download_kwargs[\"ExtraArgs\"] = {\"VersionId\": s3_object.version_id}\n    self._s3_client.download_file(\n        s3_object.bucket,\n        s3_object.key,\n        cached_filename,\n        **download_kwargs,\n    )\n\n    # Set modification (and access) time to S3's modification time. This\n    # helps with debugging and also means they'll sort by version easily\n    # with tools like \"ls -lt\".\n    get_object_kwargs = {}\n    if versioned:\n        get_object_kwargs[\"VersionId\"] = s3_object.version_id\n    response = self._s3_client.get_object(\n        Bucket=s3_object.bucket,\n        Key=s3_object.key,\n        **get_object_kwargs,\n    )\n    last_modified: datetime = response[\"LastModified\"]\n\n    self.cache.finalize_adding_file(\n        cached_filename=cached_filename,\n        s3_object=s3_object,\n        last_modified=last_modified,\n    )\n    return cached_filename\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client.from_env_variables","title":"<code>from_env_variables()</code>  <code>classmethod</code>","text":"<p>Construct an instance from environment variables.</p> <p>If one has already been constructed, we will reuse it (assumes that environment variables don't change).</p> Source code in <code>aeromancy/s3.py</code> <pre><code>@classmethod\ndef from_env_variables(cls):\n    \"\"\"Construct an instance from environment variables.\n\n    If one has already been constructed, we will reuse it (assumes that\n    environment variables don't change).\n    \"\"\"\n    global _S3_CLIENT\n    if not _S3_CLIENT:\n        _S3_CLIENT = cls(\n            aws_access_key_id=os.environ[\"AEROMANCY_AWS_ACCESS_KEY_ID\"],\n            aws_secret_access_key=os.environ[\"AEROMANCY_AWS_SECRET_ACCESS_KEY\"],\n            region_name=os.environ[\"AEROMANCY_AWS_REGION\"],\n            endpoint_url=os.environ[\"AEROMANCY_AWS_S3_ENDPOINT_URL\"],\n        )\n    return _S3_CLIENT\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client.latest_version","title":"<code>latest_version(s3_object)</code>","text":"<p>Return the latest version ID for an object.</p> <p>Raises a TypeError if s3_object doesn't have a version.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def latest_version(self, s3_object: S3Object) -&gt; str:\n    \"\"\"Return the latest version ID for an object.\n\n    Raises a TypeError if s3_object doesn't have a version.\n    \"\"\"\n    response = self._s3_client.get_object(\n        Bucket=s3_object.bucket,\n        Key=s3_object.key,\n    )\n    try:\n        return response[\"VersionId\"]\n    except KeyError as err:\n        raise TypeError(\n            f\"s3_object has no version information: {s3_object!r}\",\n        ) from err\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client.list_objects","title":"<code>list_objects(bucket, pseudodirectory)</code>","text":"<p>Return a list of all keys that match a prefix in a bucket.</p> <p>This assumes that prefix is a (pseudo)directory and will only include \"children\" of that directory and not the directory itself.</p> <p>Keys are sorted by standard Python string ordering.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def list_objects(\n    self,\n    bucket: S3Bucket | str,\n    pseudodirectory: str,\n) -&gt; list[S3Object]:\n    \"\"\"Return a list of all keys that match a prefix in a bucket.\n\n    This assumes that prefix is a (pseudo)directory and will only include\n    \"children\" of that directory and not the directory itself.\n\n    Keys are sorted by standard Python string ordering.\n    \"\"\"\n    if not pseudodirectory.endswith(\"/\"):\n        pseudodirectory += \"/\"\n\n    all_keys = sorted(\n        list_objects_iterator(self._s3_client, str(bucket), pseudodirectory),\n    )\n    return [\n        S3Object(str(bucket), key) for key in all_keys if key != pseudodirectory\n    ]\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client.list_versions","title":"<code>list_versions(s3_object)</code>","text":"<p>Return a list of all versions of a specific key in a bucket.</p> <p>Versions are sorted from oldest to newest (according to S3).</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def list_versions(self, s3_object: VersionedS3Object) -&gt; list[str]:\n    \"\"\"Return a list of all versions of a specific key in a bucket.\n\n    Versions are sorted from oldest to newest (according to S3).\n    \"\"\"\n    version_iter = version_iterator(\n        self._s3_client,\n        s3_object.bucket,\n        s3_object.key,\n    )\n    mtime_and_versions: list[tuple[datetime, str]] = [\n        (version[\"LastModified\"], version[\"VersionId\"]) for version in version_iter\n    ]\n    return [version_id for _, version_id in sorted(mtime_and_versions)]\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Client.put","title":"<code>put(local_filename, s3_object)</code>","text":"<p>Upload a local file to S3 and stores it in the cache.</p> <p>Returns a versioned copy of s3_object.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def put(\n    self,\n    local_filename: Path,\n    s3_object: S3Object,\n) -&gt; VersionedS3Object:\n    \"\"\"Upload a local file to S3 and stores it in the cache.\n\n    Returns a versioned copy of s3_object.\n    \"\"\"\n    # Check if we already have this file.\n    sha1 = file_digest(local_filename)\n    size = humanize.naturalsize(local_filename.stat().st_size)\n    existing_version_id = self.cache.get_version(s3_object=s3_object, sha1=sha1)\n    if existing_version_id is None:\n        logger.info(f\"Storing {str(local_filename)!r} ({size}) to {s3_object}\")\n        self._s3_client.upload_file(local_filename, s3_object.bucket, s3_object.key)\n        # TODO: there's a potential race condition here if two uploads of the same\n        # file happens simultaneously.\n        version_id = self.latest_version(s3_object)\n    else:\n        logger.info(\n            f\"Cache hit for {str(local_filename)!r} ({size}), skipping upload to \"\n            f\"{s3_object}\",\n        )\n        version_id = existing_version_id\n\n    versioned_s3_object = VersionedS3Object(\n        **s3_object.to_dict(),\n        version_id=version_id,\n    )\n\n    # Transfer it to the cache if it's not already there.\n    if not existing_version_id:\n        cached_filename = self.cache.get_path(versioned_s3_object)\n        shutil.copy(local_filename, cached_filename)\n\n        self.cache.finalize_adding_file(\n            s3_object=s3_object,\n            cached_filename=cached_filename,\n            sha1=sha1,\n        )\n\n    return versioned_s3_object\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Object","title":"<code>S3Object</code>","text":"<p>             Bases: <code>Struct</code></p> <p>Represents the path to an S3 object.</p> <p>Attributes:</p> Name Type Description <code>bucket</code> <code>str</code> <p>Name of an S3 bucket.</p> <code>key</code> <code>str</code> <p>Key for an object inside the S3 bucket <code>bucket</code>.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>class S3Object(msgspec.Struct, frozen=True, order=True):\n    \"\"\"Represents the path to an S3 object.\n\n    Attributes\n    ----------\n    bucket\n        Name of an S3 bucket.\n    key\n        Key for an object inside the S3 bucket `bucket`.\n    \"\"\"\n\n    bucket: str\n    key: str\n\n    def __truediv__(self, suffix: str | Path) -&gt; \"S3Object\":\n        \"\"\"Syntactic sugar to join a suffix to the key as if both are paths.\n\n        This treats the existing key as a (pseudo)directory, so it will include a slash\n        between the original key and new suffix if there wasn't one already.\n\n        Example:\n        -------\n        &gt;&gt;&gt; s = S3Object(\"bucket\", \"key\")\n        &gt;&gt;&gt; s/\"subkey\"\n        S3Object(bucket=\"bucket\", key=\"key/subkey\")\n        \"\"\"\n        return self.joinpath(str(suffix))\n\n    def joinpath(self, *pieces: str) -&gt; \"S3Object\":\n        \"\"\"Add path pieces to the `key`.\n\n        Params\n        ------\n            pieces\n                Additional strings to include in the key.\n\n        Returns\n        -------\n            A new S3Object with `pieces` appended to the key, joined with the\n            default path separator.\n        \"\"\"\n        if not pieces:\n            raise ValueError(f\"Must have at least one piece, got: {pieces!r}\")\n\n        # Make sure there's no initial slash in suffix since joining \"/a\" and\n        # \"/b\" -&gt; \"/b\" instead of \"/a/b\".\n        sanitized_piece0 = pieces[0].removeprefix(\"/\")\n        pieces = (sanitized_piece0,) + pieces[1:]\n        path = Path(self.key)\n        new_key = path.joinpath(*pieces)\n        return S3Object(self.bucket, str(new_key))\n\n    def to_dict(self):\n        \"\"\"Convert to a dictionary of field names to field values.\"\"\"\n        return {f: getattr(self, f) for f in self.__struct_fields__}\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Object.__truediv__","title":"<code>__truediv__(suffix)</code>","text":"<p>Syntactic sugar to join a suffix to the key as if both are paths.</p> <p>This treats the existing key as a (pseudo)directory, so it will include a slash between the original key and new suffix if there wasn't one already.</p> Example: <p>s = S3Object(\"bucket\", \"key\") s/\"subkey\" S3Object(bucket=\"bucket\", key=\"key/subkey\")</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def __truediv__(self, suffix: str | Path) -&gt; \"S3Object\":\n    \"\"\"Syntactic sugar to join a suffix to the key as if both are paths.\n\n    This treats the existing key as a (pseudo)directory, so it will include a slash\n    between the original key and new suffix if there wasn't one already.\n\n    Example:\n    -------\n    &gt;&gt;&gt; s = S3Object(\"bucket\", \"key\")\n    &gt;&gt;&gt; s/\"subkey\"\n    S3Object(bucket=\"bucket\", key=\"key/subkey\")\n    \"\"\"\n    return self.joinpath(str(suffix))\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Object.joinpath","title":"<code>joinpath(*pieces)</code>","text":"<p>Add path pieces to the <code>key</code>.</p> Params <pre><code>pieces\n    Additional strings to include in the key.\n</code></pre> <p>Returns:</p> Type Description <code>    A new S3Object with `pieces` appended to the key, joined with the</code> <p>default path separator.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def joinpath(self, *pieces: str) -&gt; \"S3Object\":\n    \"\"\"Add path pieces to the `key`.\n\n    Params\n    ------\n        pieces\n            Additional strings to include in the key.\n\n    Returns\n    -------\n        A new S3Object with `pieces` appended to the key, joined with the\n        default path separator.\n    \"\"\"\n    if not pieces:\n        raise ValueError(f\"Must have at least one piece, got: {pieces!r}\")\n\n    # Make sure there's no initial slash in suffix since joining \"/a\" and\n    # \"/b\" -&gt; \"/b\" instead of \"/a/b\".\n    sanitized_piece0 = pieces[0].removeprefix(\"/\")\n    pieces = (sanitized_piece0,) + pieces[1:]\n    path = Path(self.key)\n    new_key = path.joinpath(*pieces)\n    return S3Object(self.bucket, str(new_key))\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.S3Object.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to a dictionary of field names to field values.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def to_dict(self):\n    \"\"\"Convert to a dictionary of field names to field values.\"\"\"\n    return {f: getattr(self, f) for f in self.__struct_fields__}\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.VersionedS3Object","title":"<code>VersionedS3Object</code>","text":"<p>             Bases: <code>S3Object</code></p> <p>Represents the path to an versioned S3 object.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>class VersionedS3Object(S3Object, frozen=True):\n    \"\"\"Represents the path to an versioned S3 object.\"\"\"\n\n    version_id: str\n\n    def to_aeromancy_uri(self):\n        \"\"\"Return an internal URLs, purely for Aeromancy tracking with W&amp;B.\"\"\"\n        return hyperlink.URL(\n            scheme=\"aeromancy\",\n            host=self.bucket,\n            path=self.key.split(\"/\"),\n            fragment=self.version_id,\n        )\n\n    @classmethod\n    def from_aeromancy_uri(cls, aeromancy_uri: hyperlink.URL | hyperlink.DecodedURL):\n        \"\"\"Create a corresponding `VersionedS3Object` from a URL.\"\"\"\n        return cls(\n            bucket=aeromancy_uri.host,\n            key=\"/\".join(aeromancy_uri.path),\n            version_id=aeromancy_uri.fragment,\n        )\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.VersionedS3Object.from_aeromancy_uri","title":"<code>from_aeromancy_uri(aeromancy_uri)</code>  <code>classmethod</code>","text":"<p>Create a corresponding <code>VersionedS3Object</code> from a URL.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>@classmethod\ndef from_aeromancy_uri(cls, aeromancy_uri: hyperlink.URL | hyperlink.DecodedURL):\n    \"\"\"Create a corresponding `VersionedS3Object` from a URL.\"\"\"\n    return cls(\n        bucket=aeromancy_uri.host,\n        key=\"/\".join(aeromancy_uri.path),\n        version_id=aeromancy_uri.fragment,\n    )\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.VersionedS3Object.to_aeromancy_uri","title":"<code>to_aeromancy_uri()</code>","text":"<p>Return an internal URLs, purely for Aeromancy tracking with W&amp;B.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def to_aeromancy_uri(self):\n    \"\"\"Return an internal URLs, purely for Aeromancy tracking with W&amp;B.\"\"\"\n    return hyperlink.URL(\n        scheme=\"aeromancy\",\n        host=self.bucket,\n        path=self.key.split(\"/\"),\n        fragment=self.version_id,\n    )\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.file_digest","title":"<code>file_digest(filename)</code>","text":"<p>Compute the SHA1 hash of a file.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def file_digest(filename: Path) -&gt; str:\n    \"\"\"Compute the SHA1 hash of a file.\"\"\"\n    # TODO: replace with hashlib.file_digest in Python 3.11\n    sha1 = hashlib.sha1(usedforsecurity=False)\n    sha1.update(filename.open(mode=\"rb\").read())\n    return sha1.hexdigest()\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.list_objects_iterator","title":"<code>list_objects_iterator(s3_client, bucket, prefix)</code>","text":"<p>Retrieve all objects that match a prefix in a bucket.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def list_objects_iterator(s3_client, bucket, prefix):\n    \"\"\"Retrieve all objects that match a prefix in a bucket.\"\"\"\n    paginator = s3_client.get_paginator(\"list_objects_v2\")\n    response_iterator = paginator.paginate(Bucket=bucket, Prefix=prefix)\n    for response in response_iterator:\n        contents = response.get(\"Contents\")\n        if not contents:\n            raise FileNotFoundError(f\"No files matched for {bucket!r} and {prefix!r}\")\n        for entry in contents:\n            key: str = entry[\"Key\"]\n            yield key\n</code></pre>"},{"location":"reference/aeromancy/s3/#aeromancy.s3.version_iterator","title":"<code>version_iterator(s3_client, bucket, key)</code>","text":"<p>Retrieve all versions of an object.</p> Source code in <code>aeromancy/s3.py</code> <pre><code>def version_iterator(s3_client, bucket, key):\n    \"\"\"Retrieve all versions of an object.\"\"\"\n    # Apparently the S3 paginator still requires a bit of work to decode.\n    paginator = s3_client.get_paginator(\"list_object_versions\")\n    response_iterator = paginator.paginate(Bucket=bucket, Prefix=key)\n    for response in response_iterator:\n        for version in response[\"Versions\"]:\n            # Since we provided a prefix, we may get expansions of that prefix too.\n            if version[\"Key\"] != key:\n                continue\n            yield version\n</code></pre>"},{"location":"reference/aeromancy/struct/","title":"struct","text":"<p>Extended version of <code>msgspec.Struct</code> with easier serialization and validation.</p>"},{"location":"reference/aeromancy/struct/#aeromancy.struct.AeromancyStruct","title":"<code>AeromancyStruct</code>","text":"<p>             Bases: <code>Struct</code></p> <p><code>msgspec.Struct</code> baseclass with additional features.</p> <p>These includes validation, easier (de)serialization to JSON/YAML, and Aeromancy Artifact integration.</p> Source code in <code>aeromancy/struct.py</code> <pre><code>class AeromancyStruct(msgspec.Struct):\n    \"\"\"`msgspec.Struct` baseclass with additional features.\n\n    These includes validation, easier (de)serialization to JSON/YAML, and\n    Aeromancy Artifact integration.\n    \"\"\"\n\n    def encode(self, format: str) -&gt; bytes:\n        \"\"\"Serialize this `msgspec.Struct` to bytes.\n\n        Parameters\n        ----------\n        format\n            Which encoding format to use. This can be \"yaml\", \"json\", or \"msgpack\".\n\n        Returns\n        -------\n        This msgspec.Struct encoded according to `format`.\n        \"\"\"\n        match format:\n            case \"yaml\":\n                encoded = msgspec.yaml.encode(self)\n            case \"json\":\n                encoded = msgspec.json.encode(self)\n            case \"msgpack\":\n                encoded = msgspec.msgpack.encode(self)\n            case _:\n                raise ValueError(f\"Unknown format: {format!r}\")\n\n        return encoded\n\n    @classmethod\n    def decode(cls, encoded_bytes: bytes, format: str):\n        \"\"\"Deserialize this `msgspec.Struct` from bytes.\n\n        Parameters\n        ----------\n        encoded_bytes\n            Bytes to attempt to deserialize.\n        format\n            The format to used to encode the `msgspec.Struct`. This can be\n            \"yaml\", \"json\", or \"msgpack\".\n\n        Returns\n        -------\n        An instance of this class decoded according to `format`.\n        \"\"\"\n        match format:\n            case \"yaml\":\n                return msgspec.yaml.decode(encoded_bytes, type=cls)\n            case \"json\":\n                return msgspec.json.decode(encoded_bytes, type=cls)\n            case \"msgpack\":\n                return msgspec.msgpack.decode(encoded_bytes, type=cls)\n            case _:\n                raise ValueError(f\"Unknown format: {format!r}\")\n\n    def validate(self) -&gt; None:\n        \"\"\"Confirm current values of this `msgspec.Struct` match the spec.\n\n        Raises\n        ------\n        msgspec.ValidationError\n            If current values do not conform.\n        \"\"\"\n        # TODO: May eventually be part of msgspec:\n        #   https://github.com/jcrist/msgspec/issues/513\n        # In the meantime, a workaround: msgspec validates only on\n        # serialization, so we can roundtrip our data.\n        self.decode(self.encode(format=\"msgpack\"), format=\"msgpack\")\n\n    def as_json_objects(self) -&gt; JSONType:\n        \"\"\"Encode this structure as JSON using corresponding Python objects.\"\"\"\n        return json.loads(self.encode(format=\"json\"))\n\n    def to_artifact(\n        self,\n        filename: str,\n        artifact_name: str,\n        artifact_type: str,\n        s3_destination: S3Object,\n        format: str,\n        tracker: Tracker,\n    ) -&gt; AeromancyArtifact:\n        \"\"\"Save a `msgspec.Struct` object and declare it an output artifact.\n\n        We use YAML as the serialization format.\n\n        Parameters\n        ----------\n        filename\n            Where to save the object locally.\n        artifact_name\n            Name of the artifact in Weights and Biases.\n        artifact_type\n            Type of the artifact in Weights and Biases.\n        s3_destination\n            Where to save the artifacts on S3.\n        format\n            Which encoding format to use. This can be \"yaml\", \"json\", or \"msgpack\".\n        tracker\n            The current Aeromancy Tracker.\n\n        Returns\n        -------\n            `AeromancyArtifact` representing the new artifact.\n        \"\"\"\n        # The file needs to have a specific name (filename will be used directly in S3\n        # storage), so we can't use NamedTemporaryFile.\n        with tempfile.TemporaryDirectory() as tempdir:\n            full_filename = Path(tempdir) / filename\n            full_filename.write_bytes(self.encode(format))\n\n            msgspec_artifact = tracker.declare_output(\n                name=artifact_name,\n                local_filenames=[full_filename],\n                s3_destination=s3_destination,\n                artifact_type=artifact_type,\n                strip_prefix=Path(tempdir),\n            )\n\n        return msgspec_artifact\n\n    @classmethod\n    def from_artifact(\n        cls,\n        msgspec_artifact: ArtifactDescriptor,\n        format: str,\n        tracker: Tracker,\n    ):\n        \"\"\"Load a `msgspec.Struct` object and declare it an input artifact.\n\n        Parameters\n        ----------\n        msgspec_artifact\n            Artifact to load (W&amp;B artifact name or existing `AeromancyArtifact`)\n        format\n            How the artifact was encoded. This can be \"yaml\", \"json\", or \"msgpack\".\n        tracker\n            The current Aeromancy Tracker.\n\n        Returns\n        -------\n            An instance of this class with deserialized data from `msgspec_artifact`.\n\n        Raises\n        ------\n        ValueError\n            We currently require msgspec artifacts to only include a single local\n            filename in them. This will be raised if this assumption is violated.\n        \"\"\"\n        msgspec_paths = tracker.declare_input(msgspec_artifact)\n        if len(msgspec_paths) != 1:\n            raise ValueError(\n                f\"Expected 1 path for {msgspec_artifact}, got {len(msgspec_paths)}: \"\n                f\"{msgspec_paths}\",\n            )\n        [msgspec_path] = msgspec_paths\n        msgfile_bytes = msgspec_path.read_bytes()\n        return cls.decode(msgfile_bytes, format=format)\n</code></pre>"},{"location":"reference/aeromancy/struct/#aeromancy.struct.AeromancyStruct.as_json_objects","title":"<code>as_json_objects()</code>","text":"<p>Encode this structure as JSON using corresponding Python objects.</p> Source code in <code>aeromancy/struct.py</code> <pre><code>def as_json_objects(self) -&gt; JSONType:\n    \"\"\"Encode this structure as JSON using corresponding Python objects.\"\"\"\n    return json.loads(self.encode(format=\"json\"))\n</code></pre>"},{"location":"reference/aeromancy/struct/#aeromancy.struct.AeromancyStruct.decode","title":"<code>decode(encoded_bytes, format)</code>  <code>classmethod</code>","text":"<p>Deserialize this <code>msgspec.Struct</code> from bytes.</p> <p>Parameters:</p> Name Type Description Default <code>encoded_bytes</code> <code>bytes</code> <p>Bytes to attempt to deserialize.</p> required <code>format</code> <code>str</code> <p>The format to used to encode the <code>msgspec.Struct</code>. This can be \"yaml\", \"json\", or \"msgpack\".</p> required <p>Returns:</p> Type Description <code>An instance of this class decoded according to `format`.</code> Source code in <code>aeromancy/struct.py</code> <pre><code>@classmethod\ndef decode(cls, encoded_bytes: bytes, format: str):\n    \"\"\"Deserialize this `msgspec.Struct` from bytes.\n\n    Parameters\n    ----------\n    encoded_bytes\n        Bytes to attempt to deserialize.\n    format\n        The format to used to encode the `msgspec.Struct`. This can be\n        \"yaml\", \"json\", or \"msgpack\".\n\n    Returns\n    -------\n    An instance of this class decoded according to `format`.\n    \"\"\"\n    match format:\n        case \"yaml\":\n            return msgspec.yaml.decode(encoded_bytes, type=cls)\n        case \"json\":\n            return msgspec.json.decode(encoded_bytes, type=cls)\n        case \"msgpack\":\n            return msgspec.msgpack.decode(encoded_bytes, type=cls)\n        case _:\n            raise ValueError(f\"Unknown format: {format!r}\")\n</code></pre>"},{"location":"reference/aeromancy/struct/#aeromancy.struct.AeromancyStruct.encode","title":"<code>encode(format)</code>","text":"<p>Serialize this <code>msgspec.Struct</code> to bytes.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>Which encoding format to use. This can be \"yaml\", \"json\", or \"msgpack\".</p> required <p>Returns:</p> Type Description <code>This msgspec.Struct encoded according to `format`.</code> Source code in <code>aeromancy/struct.py</code> <pre><code>def encode(self, format: str) -&gt; bytes:\n    \"\"\"Serialize this `msgspec.Struct` to bytes.\n\n    Parameters\n    ----------\n    format\n        Which encoding format to use. This can be \"yaml\", \"json\", or \"msgpack\".\n\n    Returns\n    -------\n    This msgspec.Struct encoded according to `format`.\n    \"\"\"\n    match format:\n        case \"yaml\":\n            encoded = msgspec.yaml.encode(self)\n        case \"json\":\n            encoded = msgspec.json.encode(self)\n        case \"msgpack\":\n            encoded = msgspec.msgpack.encode(self)\n        case _:\n            raise ValueError(f\"Unknown format: {format!r}\")\n\n    return encoded\n</code></pre>"},{"location":"reference/aeromancy/struct/#aeromancy.struct.AeromancyStruct.from_artifact","title":"<code>from_artifact(msgspec_artifact, format, tracker)</code>  <code>classmethod</code>","text":"<p>Load a <code>msgspec.Struct</code> object and declare it an input artifact.</p> <p>Parameters:</p> Name Type Description Default <code>msgspec_artifact</code> <code>ArtifactDescriptor</code> <p>Artifact to load (W&amp;B artifact name or existing <code>AeromancyArtifact</code>)</p> required <code>format</code> <code>str</code> <p>How the artifact was encoded. This can be \"yaml\", \"json\", or \"msgpack\".</p> required <code>tracker</code> <code>Tracker</code> <p>The current Aeromancy Tracker.</p> required <p>Returns:</p> Type Description <code>    An instance of this class with deserialized data from `msgspec_artifact`.</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>We currently require msgspec artifacts to only include a single local filename in them. This will be raised if this assumption is violated.</p> Source code in <code>aeromancy/struct.py</code> <pre><code>@classmethod\ndef from_artifact(\n    cls,\n    msgspec_artifact: ArtifactDescriptor,\n    format: str,\n    tracker: Tracker,\n):\n    \"\"\"Load a `msgspec.Struct` object and declare it an input artifact.\n\n    Parameters\n    ----------\n    msgspec_artifact\n        Artifact to load (W&amp;B artifact name or existing `AeromancyArtifact`)\n    format\n        How the artifact was encoded. This can be \"yaml\", \"json\", or \"msgpack\".\n    tracker\n        The current Aeromancy Tracker.\n\n    Returns\n    -------\n        An instance of this class with deserialized data from `msgspec_artifact`.\n\n    Raises\n    ------\n    ValueError\n        We currently require msgspec artifacts to only include a single local\n        filename in them. This will be raised if this assumption is violated.\n    \"\"\"\n    msgspec_paths = tracker.declare_input(msgspec_artifact)\n    if len(msgspec_paths) != 1:\n        raise ValueError(\n            f\"Expected 1 path for {msgspec_artifact}, got {len(msgspec_paths)}: \"\n            f\"{msgspec_paths}\",\n        )\n    [msgspec_path] = msgspec_paths\n    msgfile_bytes = msgspec_path.read_bytes()\n    return cls.decode(msgfile_bytes, format=format)\n</code></pre>"},{"location":"reference/aeromancy/struct/#aeromancy.struct.AeromancyStruct.to_artifact","title":"<code>to_artifact(filename, artifact_name, artifact_type, s3_destination, format, tracker)</code>","text":"<p>Save a <code>msgspec.Struct</code> object and declare it an output artifact.</p> <p>We use YAML as the serialization format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Where to save the object locally.</p> required <code>artifact_name</code> <code>str</code> <p>Name of the artifact in Weights and Biases.</p> required <code>artifact_type</code> <code>str</code> <p>Type of the artifact in Weights and Biases.</p> required <code>s3_destination</code> <code>S3Object</code> <p>Where to save the artifacts on S3.</p> required <code>format</code> <code>str</code> <p>Which encoding format to use. This can be \"yaml\", \"json\", or \"msgpack\".</p> required <code>tracker</code> <code>Tracker</code> <p>The current Aeromancy Tracker.</p> required <p>Returns:</p> Type Description <code>    `AeromancyArtifact` representing the new artifact.</code> Source code in <code>aeromancy/struct.py</code> <pre><code>def to_artifact(\n    self,\n    filename: str,\n    artifact_name: str,\n    artifact_type: str,\n    s3_destination: S3Object,\n    format: str,\n    tracker: Tracker,\n) -&gt; AeromancyArtifact:\n    \"\"\"Save a `msgspec.Struct` object and declare it an output artifact.\n\n    We use YAML as the serialization format.\n\n    Parameters\n    ----------\n    filename\n        Where to save the object locally.\n    artifact_name\n        Name of the artifact in Weights and Biases.\n    artifact_type\n        Type of the artifact in Weights and Biases.\n    s3_destination\n        Where to save the artifacts on S3.\n    format\n        Which encoding format to use. This can be \"yaml\", \"json\", or \"msgpack\".\n    tracker\n        The current Aeromancy Tracker.\n\n    Returns\n    -------\n        `AeromancyArtifact` representing the new artifact.\n    \"\"\"\n    # The file needs to have a specific name (filename will be used directly in S3\n    # storage), so we can't use NamedTemporaryFile.\n    with tempfile.TemporaryDirectory() as tempdir:\n        full_filename = Path(tempdir) / filename\n        full_filename.write_bytes(self.encode(format))\n\n        msgspec_artifact = tracker.declare_output(\n            name=artifact_name,\n            local_filenames=[full_filename],\n            s3_destination=s3_destination,\n            artifact_type=artifact_type,\n            strip_prefix=Path(tempdir),\n        )\n\n    return msgspec_artifact\n</code></pre>"},{"location":"reference/aeromancy/struct/#aeromancy.struct.AeromancyStruct.validate","title":"<code>validate()</code>","text":"<p>Confirm current values of this <code>msgspec.Struct</code> match the spec.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If current values do not conform.</p> Source code in <code>aeromancy/struct.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Confirm current values of this `msgspec.Struct` match the spec.\n\n    Raises\n    ------\n    msgspec.ValidationError\n        If current values do not conform.\n    \"\"\"\n    # TODO: May eventually be part of msgspec:\n    #   https://github.com/jcrist/msgspec/issues/513\n    # In the meantime, a workaround: msgspec validates only on\n    # serialization, so we can roundtrip our data.\n    self.decode(self.encode(format=\"msgpack\"), format=\"msgpack\")\n</code></pre>"},{"location":"reference/aeromancy/tracker/","title":"tracker","text":"<p>Record details around code execution for repeatable data pipelines.</p> <p>A Tracker is responsible for tracking the running of specific code, where tracking includes the operating system state (Docker), external artifacts (S3), the code itself (GitHub). Trackers also help organize runs, generally following Weights and Biases organization.</p> <p>In general, Trackers should be used as context managers surrounding the code to be tracked.</p> <p>Terminological note: The closest corresponding object in Weights and Biases is a <code>Run</code>. Aeromancy Trackers have a different name to distinguish them from W&amp;B runs and indicate a larger scope.</p>"},{"location":"reference/aeromancy/tracker/#aeromancy.tracker.Tracker","title":"<code>Tracker</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A single, logged piece of computation.</p> <p>This version of the class is abstract to specify the interface.</p> Source code in <code>aeromancy/tracker.py</code> <pre><code>class Tracker(ABC):\n    \"\"\"A single, logged piece of computation.\n\n    This version of the class is abstract to specify the interface.\n    \"\"\"\n\n    def __init__(\n        self,\n        project_name: str,\n        config: dict | None = None,\n        job_type: str | None = None,\n        job_group: str | None = None,\n    ):\n        \"\"\"Create a Tracker.\n\n        Several parameters are purely for organization purposes. The hierarchy\n        is essentially:\n\n            project_name\n                job_group\n                    job_type\n                        (individual run)\n\n        Parameters\n        ----------\n        project_name\n            Name of the project, should correspond to a W&amp;B project.\n        config, optional\n            Input parameters to a task. For ML, these include hyperparameters.\n            For other tasks, these can include things such as command line\n            flags.\n        job_type, optional\n            Typically used to describe the action of a specific task (e.g.,\n            \"munge\", \"evaluate\")\n        job_group, optional\n            Typically used to describe the general goal of a group of tasks\n            (e.g., \"build\", \"model\")\n        \"\"\"\n        self.project_name = project_name\n        self.config = config\n        self.job_type = job_type\n        self.job_group = job_group\n\n    @abstractmethod\n    def __enter__(self):\n        \"\"\"Use this Tracker as a context manager.\n\n        This should be run before running the code to track.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def __exit__(self, exctype, excinst, exctb) -&gt; bool:\n        \"\"\"Finish using this Tracker as a context manager.\n\n        This should be run after running the code to track.\n        Parameters and return values are standard for context managers.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def declare_output(\n        self,\n        name: str,\n        local_filenames: Sequence[Path],\n        s3_destination: S3Object,\n        artifact_type: str,\n        strip_prefix: Path | None = None,\n        metadata: dict | None = None,\n    ) -&gt; AeromancyArtifact:\n        \"\"\"Declare and store local files as associated artifacts.\n\n        These are uploaded and versioned on S3 and versioned on W&amp;B.\n\n        Parameters\n        ----------\n        name\n            Name for the output artifact.\n        local_filenames\n            Paths to local files to be stored and associated with the artifact.\n        s3_destination\n            Where to store the artifacts on S3 (bucket and prefix for keys).\n            Actual keys will be combined with the filenames in\n            `local_filename_or_filenames`.\n        artifact_type, optional\n            Approximate type of the artifact, typically used as a human readable\n            extension (e.g., \"dataset\", \"predictions\", \"metadata\").\n        strip_prefix, optional\n            Parts of the local filenames which should not be part of the\n            structure when copied to S3. For example, if you want to store a\n            file `/tmp/results.txt` but exclude `/tmp/`, you'd set\n            `strip_prefix=Path('/tmp')`.\n        metadata\n            Any extra information to be associated with the artifact.\n\n        Returns\n        -------\n            `AeromancyArtifact` representing this output.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def declare_input(\n        self,\n        artifact: AeromancyArtifact | str,\n        use_as: str | None = None,\n    ) -&gt; Sequence[Path]:\n        \"\"\"Declare that this run depends on an existing artifact.\n\n        If needed, this will fetch and catch the corresponding files for the artifact.\n\n        Parameters\n        ----------\n        artifact\n            An existing AeromancyArtifact or a W&amp;B full name. A Weights &amp; Biases\n            full name is obtained from clicking the \"Full name\" field\n            in the Version overview for an artifact.\n        use_as, optional\n            Additional metadata to track how this is being used.\n\n        Returns\n        -------\n            Local paths to the artifact.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def log(self, metrics: dict[str, Any]) -&gt; None:\n        \"\"\"Record a set of metrics to be associated with this run.\n\n        Parameters\n        ----------\n        metrics\n            Dictionary of string to any type of object that W&amp;B will accept.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/tracker/#aeromancy.tracker.Tracker.__enter__","title":"<code>__enter__()</code>  <code>abstractmethod</code>","text":"<p>Use this Tracker as a context manager.</p> <p>This should be run before running the code to track.</p> Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef __enter__(self):\n    \"\"\"Use this Tracker as a context manager.\n\n    This should be run before running the code to track.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/tracker/#aeromancy.tracker.Tracker.__exit__","title":"<code>__exit__(exctype, excinst, exctb)</code>  <code>abstractmethod</code>","text":"<p>Finish using this Tracker as a context manager.</p> <p>This should be run after running the code to track. Parameters and return values are standard for context managers.</p> Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef __exit__(self, exctype, excinst, exctb) -&gt; bool:\n    \"\"\"Finish using this Tracker as a context manager.\n\n    This should be run after running the code to track.\n    Parameters and return values are standard for context managers.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/tracker/#aeromancy.tracker.Tracker.__init__","title":"<code>__init__(project_name, config=None, job_type=None, job_group=None)</code>","text":"<p>Create a Tracker.</p> <p>Several parameters are purely for organization purposes. The hierarchy is essentially:</p> <pre><code>project_name\n    job_group\n        job_type\n            (individual run)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of the project, should correspond to a W&amp;B project.</p> required <code>config</code> <code>dict | None</code> <p>Input parameters to a task. For ML, these include hyperparameters. For other tasks, these can include things such as command line flags.</p> <code>None</code> <code>optional</code> <code>dict | None</code> <p>Input parameters to a task. For ML, these include hyperparameters. For other tasks, these can include things such as command line flags.</p> <code>None</code> <code>job_type</code> <code>str | None</code> <p>Typically used to describe the action of a specific task (e.g., \"munge\", \"evaluate\")</p> <code>None</code> <code>optional</code> <code>str | None</code> <p>Typically used to describe the action of a specific task (e.g., \"munge\", \"evaluate\")</p> <code>None</code> <code>job_group</code> <code>str | None</code> <p>Typically used to describe the general goal of a group of tasks (e.g., \"build\", \"model\")</p> <code>None</code> <code>optional</code> <code>str | None</code> <p>Typically used to describe the general goal of a group of tasks (e.g., \"build\", \"model\")</p> <code>None</code> Source code in <code>aeromancy/tracker.py</code> <pre><code>def __init__(\n    self,\n    project_name: str,\n    config: dict | None = None,\n    job_type: str | None = None,\n    job_group: str | None = None,\n):\n    \"\"\"Create a Tracker.\n\n    Several parameters are purely for organization purposes. The hierarchy\n    is essentially:\n\n        project_name\n            job_group\n                job_type\n                    (individual run)\n\n    Parameters\n    ----------\n    project_name\n        Name of the project, should correspond to a W&amp;B project.\n    config, optional\n        Input parameters to a task. For ML, these include hyperparameters.\n        For other tasks, these can include things such as command line\n        flags.\n    job_type, optional\n        Typically used to describe the action of a specific task (e.g.,\n        \"munge\", \"evaluate\")\n    job_group, optional\n        Typically used to describe the general goal of a group of tasks\n        (e.g., \"build\", \"model\")\n    \"\"\"\n    self.project_name = project_name\n    self.config = config\n    self.job_type = job_type\n    self.job_group = job_group\n</code></pre>"},{"location":"reference/aeromancy/tracker/#aeromancy.tracker.Tracker.declare_input","title":"<code>declare_input(artifact, use_as=None)</code>  <code>abstractmethod</code>","text":"<p>Declare that this run depends on an existing artifact.</p> <p>If needed, this will fetch and catch the corresponding files for the artifact.</p> <p>Parameters:</p> Name Type Description Default <code>artifact</code> <code>AeromancyArtifact | str</code> <p>An existing AeromancyArtifact or a W&amp;B full name. A Weights &amp; Biases full name is obtained from clicking the \"Full name\" field in the Version overview for an artifact.</p> required <code>use_as</code> <code>str | None</code> <p>Additional metadata to track how this is being used.</p> <code>None</code> <code>optional</code> <code>str | None</code> <p>Additional metadata to track how this is being used.</p> <code>None</code> <p>Returns:</p> Type Description <code>    Local paths to the artifact.</code> Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef declare_input(\n    self,\n    artifact: AeromancyArtifact | str,\n    use_as: str | None = None,\n) -&gt; Sequence[Path]:\n    \"\"\"Declare that this run depends on an existing artifact.\n\n    If needed, this will fetch and catch the corresponding files for the artifact.\n\n    Parameters\n    ----------\n    artifact\n        An existing AeromancyArtifact or a W&amp;B full name. A Weights &amp; Biases\n        full name is obtained from clicking the \"Full name\" field\n        in the Version overview for an artifact.\n    use_as, optional\n        Additional metadata to track how this is being used.\n\n    Returns\n    -------\n        Local paths to the artifact.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/tracker/#aeromancy.tracker.Tracker.declare_output","title":"<code>declare_output(name, local_filenames, s3_destination, artifact_type, strip_prefix=None, metadata=None)</code>  <code>abstractmethod</code>","text":"<p>Declare and store local files as associated artifacts.</p> <p>These are uploaded and versioned on S3 and versioned on W&amp;B.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the output artifact.</p> required <code>local_filenames</code> <code>Sequence[Path]</code> <p>Paths to local files to be stored and associated with the artifact.</p> required <code>s3_destination</code> <code>S3Object</code> <p>Where to store the artifacts on S3 (bucket and prefix for keys). Actual keys will be combined with the filenames in <code>local_filename_or_filenames</code>.</p> required <code>artifact_type</code> <code>str</code> <p>Approximate type of the artifact, typically used as a human readable extension (e.g., \"dataset\", \"predictions\", \"metadata\").</p> required <code>optional</code> <code>str</code> <p>Approximate type of the artifact, typically used as a human readable extension (e.g., \"dataset\", \"predictions\", \"metadata\").</p> required <code>strip_prefix</code> <code>Path | None</code> <p>Parts of the local filenames which should not be part of the structure when copied to S3. For example, if you want to store a file <code>/tmp/results.txt</code> but exclude <code>/tmp/</code>, you'd set <code>strip_prefix=Path('/tmp')</code>.</p> <code>None</code> <code>optional</code> <code>Path | None</code> <p>Parts of the local filenames which should not be part of the structure when copied to S3. For example, if you want to store a file <code>/tmp/results.txt</code> but exclude <code>/tmp/</code>, you'd set <code>strip_prefix=Path('/tmp')</code>.</p> <code>None</code> <code>metadata</code> <code>dict | None</code> <p>Any extra information to be associated with the artifact.</p> <code>None</code> <p>Returns:</p> Type Description <code>    `AeromancyArtifact` representing this output.</code> Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef declare_output(\n    self,\n    name: str,\n    local_filenames: Sequence[Path],\n    s3_destination: S3Object,\n    artifact_type: str,\n    strip_prefix: Path | None = None,\n    metadata: dict | None = None,\n) -&gt; AeromancyArtifact:\n    \"\"\"Declare and store local files as associated artifacts.\n\n    These are uploaded and versioned on S3 and versioned on W&amp;B.\n\n    Parameters\n    ----------\n    name\n        Name for the output artifact.\n    local_filenames\n        Paths to local files to be stored and associated with the artifact.\n    s3_destination\n        Where to store the artifacts on S3 (bucket and prefix for keys).\n        Actual keys will be combined with the filenames in\n        `local_filename_or_filenames`.\n    artifact_type, optional\n        Approximate type of the artifact, typically used as a human readable\n        extension (e.g., \"dataset\", \"predictions\", \"metadata\").\n    strip_prefix, optional\n        Parts of the local filenames which should not be part of the\n        structure when copied to S3. For example, if you want to store a\n        file `/tmp/results.txt` but exclude `/tmp/`, you'd set\n        `strip_prefix=Path('/tmp')`.\n    metadata\n        Any extra information to be associated with the artifact.\n\n    Returns\n    -------\n        `AeromancyArtifact` representing this output.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/tracker/#aeromancy.tracker.Tracker.log","title":"<code>log(metrics)</code>  <code>abstractmethod</code>","text":"<p>Record a set of metrics to be associated with this run.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>dict[str, Any]</code> <p>Dictionary of string to any type of object that W&amp;B will accept.</p> required Source code in <code>aeromancy/tracker.py</code> <pre><code>@abstractmethod\ndef log(self, metrics: dict[str, Any]) -&gt; None:\n    \"\"\"Record a set of metrics to be associated with this run.\n\n    Parameters\n    ----------\n    metrics\n        Dictionary of string to any type of object that W&amp;B will accept.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/aeromancy/wandb_tracker/","title":"wandb_tracker","text":"<p>Tracker backed by Weights and Biases and S3.</p> <p>Weights and Biases is used to track runs and S3 to store artifacts.</p>"},{"location":"reference/aeromancy/wandb_tracker/#aeromancy.wandb_tracker.WandbTracker","title":"<code>WandbTracker</code>","text":"<p>             Bases: <code>Tracker</code></p> <p>A single, logged piece of computation.</p> <p>This class uses Weights and Biases (W&amp;B) as a backend for tracking.</p> Source code in <code>aeromancy/wandb_tracker.py</code> <pre><code>class WandbTracker(Tracker):\n    \"\"\"A single, logged piece of computation.\n\n    This class uses Weights and Biases (W&amp;B) as a backend for tracking.\n    \"\"\"\n\n    @override\n    def __init__(\n        self,\n        project_name: str,\n        config: dict | None = None,\n        job_type: str | None = None,\n        job_group: str | None = None,\n        quiet: bool = True,\n    ):\n        Tracker.__init__(\n            self,\n            project_name=project_name,\n            config=config,\n            job_type=job_type,\n            job_group=job_group,\n        )\n\n        self.quiet = quiet\n\n        runtime_environment = get_runtime_environment()\n        git_ref = runtime_environment.git_commit_hash or \"\"\n        # For \"https://github.com/x/y.git\", we'd pull out \"y\" as the job name\n        job_name = runtime_environment.git_repo_name\n\n        # Run wandb init with our extra tracking data.\n        notes = f\"{runtime_environment.git_message} (git message for {git_ref[:6]})\"\n        wandb_run = wandb.init(\n            project=project_name,\n            config=config or {},\n            job_type=job_type,\n            group=job_group,\n            notes=notes,\n            tags=[f\"git/{runtime_environment.git_branch}\"],\n            settings=wandb.Settings(\n                job_name=job_name,\n                git_commit=git_ref,\n                git_remote_url=runtime_environment.git_remote_url,\n                docker=runtime_environment.docker_hash,\n                quiet=self.quiet,\n            ),\n        )\n        if not isinstance(wandb_run, wandb.sdk.wandb_run.Run):\n            raise TypeError(\n                f\"Didn't get a valid run from Weights and Biases: {wandb_run}\",\n            )\n        else:\n            self.wandb_run = wandb_run\n\n        self._artifacts = Artifacts(self.wandb_run)\n\n    @override\n    def __enter__(self):\n        get_runtime_environment().confirm_running_from_container()\n        self.wandb_run.__enter__()\n        self._log_docker_package_versions()\n\n        return self\n\n    def _log_docker_package_versions(self):\n        \"\"\"Log all Docker package versions as a Weights and Biases Table artifact.\"\"\"\n        # packages_list.txt is created as part of Docker image construciton.\n        packages_list = Path(\"/base/packages_list.txt\").read_text()\n        rows = [line.split(\"=\", 1) for line in packages_list.splitlines()]\n        package_version_table = wandb.Table(\n            data=rows,\n            columns=[\"package_name\", \"version\"],\n        )\n        self.wandb_run.log(\n            {\"docker_package_versions\": package_version_table},\n            commit=False,\n        )\n\n    @override\n    def __exit__(self, exctype, excinst, exctb) -&gt; bool:\n        had_error = exctype is not None\n        if had_error:\n            logger.exception(excinst)\n        self.wandb_run.finish(quiet=self.quiet, exit_code=had_error)\n        # TODO: find a better way to do this without lots of repeated stacktraces?\n        return self.wandb_run.__exit__(exctype, excinst, exctb)\n\n    @override\n    def declare_output(\n        self,\n        name: str,\n        local_filenames: Sequence[Path],\n        s3_destination: S3Object,\n        artifact_type: str,\n        strip_prefix: Path | None = None,\n        metadata: dict | None = None,\n    ) -&gt; AeromancyArtifact:\n        return self._artifacts.declare_output(\n            name=name,\n            local_filenames=local_filenames,\n            s3_destination=s3_destination,\n            artifact_type=artifact_type,\n            strip_prefix=strip_prefix,\n            metadata=metadata,\n        )\n\n    @override\n    def declare_input(\n        self,\n        artifact: AeromancyArtifact | str,\n        use_as: str | None = None,\n    ) -&gt; Sequence[Path]:\n        return self._artifacts.declare_input(artifact, use_as)\n\n    @override\n    def log(self, metrics: dict[str, Any]):\n        wandb.log(metrics)\n</code></pre>"}]}